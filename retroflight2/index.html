<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro Pseudo-3D Flight — Wireframe Terrain</title>
<style>
:root{
  --bg:#050613;
  --panel: rgba(6,10,20,0.7);
  --accent:#33ffdd;
  --muted:#9aa7c9;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial}
canvas{display:block;width:100vw;height:100vh}
.ui{
  position:fixed;right:16px;top:16px;width:340px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  transition: transform 0.3s ease, opacity 0.3s ease;
}
.ui.hidden{
  transform: translateX(100%);
  opacity: 0;
  pointer-events: none;
}
.ui-toggle{
  position:fixed;right:16px;top:16px;width:44px;height:44px;border-radius:50%;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.3s ease;z-index:1000;
}
.ui-toggle:hover{
  transform: scale(1.1);
}
.ui-toggle.hidden{
  opacity: 0;
  pointer-events: none;
}
.ui h3{margin:0 0 10px 0;color:var(--accent);font-size:16px}
.row{display:flex;align-items:center;gap:8px;margin:8px 0}
.row label{flex:1;font-size:13px}
.row input[type=range]{flex:2}
.row input[type=color]{width:44px;height:30px;border-radius:6px;border:1px solid rgba(255,255,255,0.06)}
.row select{flex:2;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.5);color:var(--muted)}
.controls{display:flex;gap:8px;margin-top:8px}
.controls button{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}
.checkbox{display:flex;align-items:center;gap:8px}
.small{font-size:12px;color:#6f7ba6}
.game-info{
  position:fixed;left:16px;top:16px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  font-size:13px;display:none;
}
.game-info.active{display:block;}
@media (max-width:420px){.ui{left:6px;right:6px;width:auto}}
</style>
</head>
<body>
<canvas id="cnv"></canvas>
<div class="ui" id="ui">
  <h3>Retro Flight — настройки (псевдо‑3D)</h3>
  <div class="row"><label>Модель корабля</label>
    <select id="shipType">
      <option value="1">Истребитель</option>
      <option value="2">Крейсер</option>
      <option value="3">Разведчик</option>
    </select>
  </div>
  <div class="row"><label>Цвет корабля (основной)</label><input id="shipColor" type="color" value="#33ffdd"></div>
  <div class="row"><label>Цвет корабля (дополнительный)</label><input id="shipAccentColor" type="color" value="#aaffff"></div>
  <div class="row"><label>Скорость полёта</label><input id="speed" type="range" min="0" max="3" step="0.01" value="1"></div>
  <div class="row"><label>Высота рельефа</label><input id="amplitude" type="range" min="5" max="500" step="1" value="120"></div>
  <div class="row"><label>Частота шума</label><input id="freq" type="range" min="0.2" max="6" step="0.01" value="1.5"></div>
  <div class="row"><label>Угол камеры (deg)</label><input id="pitch" type="range" min="5" max="40" step="0.5" value="18"></div>
  <div class="row"><label>Отдалённость (fov)</label><input id="fov" type="range" min="200" max="1800" step="10" value="900"></div>
  <div class="row"><label>Сегменты (гориз.)</label><input id="segments" type="range" min="24" max="400" step="1" value="200"></div>
  <div class="row"><label>Глубина (рядов)</label><input id="depth" type="range" min="12" max="300" step="1" value="150"></div>
  <div class="row"><label>Ширина линий</label><input id="lineWidth" type="range" min="0.2" max="3.5" step="0.1" value="1"></div>
  <div class="row"><label>Цвет ландшафта</label><input id="color" type="color" value="#33ffdd"></div>
  <div class="row checkbox"><input id="showGrid" type="checkbox"><label for="showGrid">Показать сетку (grid)</label></div>
  <div class="row checkbox"><input id="shipWobble" type="checkbox" checked><label for="shipWobble">Корабль качается</label></div>
  <div class="row checkbox"><input id="shipFill" type="checkbox"><label for="shipFill">Заливка корабля</label></div>
  <div class="row checkbox"><input id="gradientColor" type="checkbox" checked><label for="gradientColor">Градиентный цвет</label></div>
  <div class="row checkbox"><input id="gameMode" type="checkbox"><label for="gameMode">Игровой режим</label></div>

  <div class="controls">
    <button id="hideUI">Скрыть настройки</button>
    <button id="pause">Пауза</button>
    <button id="reset">Сброс</button>
  </div>
  <div class="small">В игровом режиме используйте стрелки ← → для управления. Избегайте столкновений с рельефом!</div>
</div>

<div class="ui-toggle hidden" id="uiToggle">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"/>
  </svg>
</div>

<div class="game-info" id="gameInfo">
  <div>Управление: ← →</div>
  <div>Скорость: <span id="gameSpeed">0</span></div>
  <div>Дистанция: <span id="gameDistance">0</span></div>
  <div>Статус: <span id="gameStatus">✅ В полёте</span></div>
</div>

<script>
// ----------------------------- Helpers: noise (2D value noise) -----------------------------
function hash(ix, iy){
  // 32-bit integer hash
  let h = ix*374761393 + iy*668265263; h = (h ^ (h >> 13)) * 1274126177; h = (h ^ (h >> 16));
  return (h >>> 0) / 4294967295;
}
function smoothstep(t){ return t * t * (3 - 2 * t); }
function valueNoise2D(x, y){
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  const a = hash(xi, yi);
  const b = hash(xi+1, yi);
  const c = hash(xi, yi+1);
  const d = hash(xi+1, yi+1);
  const u = smoothstep(xf);
  const v = smoothstep(yf);
  const lerp = (A,B,t)=> A + (B-A)*t;
  const ab = lerp(a,b,u);
  const cd = lerp(c,d,u);
  return lerp(ab, cd, v);
}

// Fractal noise (fbm) с более резкими пиками
function fbm(x,y,octaves, lacunarity, gain){
  let sum=0, amp=1, freq=1, max=0;
  for(let i=0;i<octaves;i++){
    // Используем более агрессивную функцию для острых пиков
    let noiseVal = valueNoise2D(x*freq, y*freq);
    noiseVal = Math.pow(noiseVal, 1.5); // Делаем пики более острыми
    sum += noiseVal * amp;
    max += amp; amp *= gain; freq *= lacunarity;
  }
  return sum / max;
}

// ----------------------------- Canvas & state -----------------------------
const canvas = document.getElementById('cnv');
const ctx = canvas.getContext('2d');
let W = 0, H = 0;
function resize(){
  const dpr = window.devicePixelRatio || 1;
  W = canvas.width = Math.floor(innerWidth * dpr);
  H = canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize);
resize();

// Settings
const UI = {
  shipType: '1',
  shipColor: '#33ffdd',
  shipAccentColor: '#aaffff',
  speed:1,
  amplitude:120,
  freq:1.5,
  pitch:18, // degrees
  fov:900,
  segments:200,
  depth:150,
  lineWidth:1,
  color:'#33ffdd',
  showGrid:false,
  shipWobble:true,
  shipFill:false,
  gradientColor:true,
  gameMode: false
};

// Game state
const Game = {
  shipX: 0,
  distance: 0,
  crashed: false,
  keys: {
    left: false,
    right: false
  }
};

// bind UI controls
function $(id){ return document.getElementById(id); }
['speed','amplitude','freq','pitch','fov','segments','depth','lineWidth','color','shipType','shipColor','shipAccentColor'].forEach(id=>{
  const el = $(id);
  el.addEventListener('input', ()=>{
    const v = el.type === 'range' ? parseFloat(el.value) : el.value;
    UI[id] = v;
    if(id==='segments' || id==='depth') rebuildGrid();
  });
});
$('showGrid').addEventListener('change', e=> UI.showGrid = e.target.checked);
$('shipWobble').addEventListener('change', e=> UI.shipWobble = e.target.checked);
$('shipFill').addEventListener('change', e=> UI.shipFill = e.target.checked);
$('gradientColor').addEventListener('change', e=> UI.gradientColor = e.target.checked);
$('gameMode').addEventListener('change', e=> {
  UI.gameMode = e.target.checked;
  $('gameInfo').classList.toggle('active', UI.gameMode);
  if (UI.gameMode) {
    Game.shipX = 0;
    Game.distance = 0;
    Game.crashed = false;
  }
});

let paused=false; $('pause').addEventListener('click', ()=>{ paused = !paused; $('pause').textContent = paused ? 'Возобновить' : 'Пауза'; });
$('reset').addEventListener('click', ()=>{ rebuildGrid(true); });
$('hideUI').addEventListener('click', ()=>{ 
  $('ui').classList.add('hidden');
  $('uiToggle').classList.remove('hidden');
});

$('uiToggle').addEventListener('click', ()=>{ 
  $('ui').classList.remove('hidden');
  $('uiToggle').classList.add('hidden');
});

// Keyboard controls for game mode
document.addEventListener('keydown', (e) => {
  if (!UI.gameMode || paused) return;
  
  if (e.key === 'ArrowLeft') Game.keys.left = true;
  if (e.key === 'ArrowRight') Game.keys.right = true;
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') Game.keys.left = false;
  if (e.key === 'ArrowRight') Game.keys.right = false;
});

// Terrain grid parameters
let segments = Math.max(24, Math.floor(UI.segments));
let depthSteps = Math.max(12, Math.floor(UI.depth));
let grid = []; // grid[depthIndex][segIndex] = {x,y,z}
let timeOffset = 0;

function rebuildGrid(forceRandom=false){
  segments = Math.max(24, Math.floor(UI.segments));
  depthSteps = Math.max(12, Math.floor(UI.depth));
  grid = [];
  for(let d=0; d<depthSteps; d++){
    const row = [];
    for(let s=0; s<=segments; s++){
      row.push({x:0,y:0,z:0});
    }
    grid.push(row);
  }
}
rebuildGrid();

// projection: transform point (x_world, y_world, z_world) to screen
function projectPoint(px, py, pz, camera){
  // camera: {x,y,z, pitchRad, fov}
  // translate to camera space (camera at origin looking along +z)
  const x = px - camera.x;
  const y = py - camera.y;
  const z = pz - camera.z;
  // rotate around x (pitch)
  const sinp = Math.sin(camera.pitch), cosp = Math.cos(camera.pitch);
  const z2 = z * cosp - y * sinp;
  const y2 = z * sinp + y * cosp;
  // only draw points in front of camera
  if(z2 <= 1) return null;
  const scale = camera.fov / z2;
  const sx = camera.cx + x * scale;
  const sy = camera.cy - y2 * scale;
  return {sx, sy, scale};
}

// Функция для создания градиентного цвета на основе глубины
function getGradientColor(baseColor, depthRatio) {
  if (!UI.gradientColor) return baseColor;
  
  // Преобразуем hex в RGB
  const r = parseInt(baseColor.slice(1, 3), 16);
  const g = parseInt(baseColor.slice(3, 5), 16);
  const b = parseInt(baseColor.slice(5, 7), 16);
  
  // Создаем градиент от основного цвета к синему для далеких объектов
  const targetR = 50;
  const targetG = 100;
  const targetB = 200;
  
  const mix = Math.pow(depthRatio, 0.7); // Более плавный переход
  
  const resultR = Math.floor(r * (1 - mix) + targetR * mix);
  const resultG = Math.floor(g * (1 - mix) + targetG * mix);
  const resultB = Math.floor(b * (1 - mix) + targetB * mix);
  
  return `rgb(${resultR}, ${resultG}, ${resultB})`;
}

// Рисование корабля типа 1 - Истребитель (ультра детализированный)
function drawShipFighter(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  // В игровом режиме учитываем позицию корабля
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180);
  
  const scale = 1.2;
  const enginePulse = Math.abs(Math.sin(t * 0.01)) * 0.5 + 0.5;
  
  // Основные цвета
  const mainColor = primaryColor;
  const engineColor = `rgba(255, 100, 50, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // Меньше прозрачности (93%)
  
  // Если включена заливка, сначала заливаем
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // Основной контур корпуса для заливки
    ctx.moveTo(0, -22 * scale);
    ctx.bezierCurveTo(-8 * scale, -20 * scale, -15 * scale, -15 * scale, -25 * scale, -5 * scale);
    ctx.bezierCurveTo(-30 * scale, 2 * scale, -28 * scale, 12 * scale, -22 * scale, 18 * scale);
    ctx.lineTo(-15 * scale, 22 * scale);
    ctx.lineTo(15 * scale, 22 * scale);
    ctx.lineTo(22 * scale, 18 * scale);
    ctx.bezierCurveTo(28 * scale, 12 * scale, 30 * scale, 2 * scale, 25 * scale, -5 * scale);
    ctx.bezierCurveTo(15 * scale, -15 * scale, 8 * scale, -20 * scale, 0, -22 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  // Основной корпус
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // Контур истребителя
  ctx.moveTo(0, -22 * scale);
  ctx.bezierCurveTo(-8 * scale, -20 * scale, -15 * scale, -15 * scale, -25 * scale, -5 * scale);
  ctx.bezierCurveTo(-30 * scale, 2 * scale, -28 * scale, 12 * scale, -22 * scale, 18 * scale);
  ctx.lineTo(-15 * scale, 22 * scale);
  ctx.lineTo(15 * scale, 22 * scale);
  ctx.lineTo(22 * scale, 18 * scale);
  ctx.bezierCurveTo(28 * scale, 12 * scale, 30 * scale, 2 * scale, 25 * scale, -5 * scale);
  ctx.bezierCurveTo(15 * scale, -15 * scale, 8 * scale, -20 * scale, 0, -22 * scale);
  
  // Центральная линия
  ctx.moveTo(0, -22 * scale);
  ctx.lineTo(0, 22 * scale);
  
  // Горизонтальные ребра жесткости (очень плотная сетка)
  for (let i = -20; i <= 20; i += 1.5) {
    const y = i * scale;
    const curveFactor = Math.sin(i * 0.15) * 3;
    const width = (15 + Math.abs(i) * 0.7 + curveFactor) * scale;
    if (i === 0) continue;
    ctx.moveTo(-width, y);
    ctx.lineTo(width, y);
  }
  
  // Вертикальные ребра жесткости (очень плотная сетка)
  for (let i = -28; i <= 28; i += 2) {
    const x = i * scale;
    if (Math.abs(x) > 30 * scale) continue;
    const curveFactor = Math.cos(x * 0.05) * 4;
    const height = (22 - Math.abs(i) * 0.5 + curveFactor) * scale;
    if (x === 0) continue;
    ctx.moveTo(x, -height);
    ctx.lineTo(x, height);
  }
  
  // Диагональные ребра жесткости для объема (очень плотная сетка)
  for (let i = -20; i <= 20; i += 3) {
    const y = i * scale;
    // Левая диагональ
    ctx.moveTo(-25 * scale, -5 * scale);
    ctx.lineTo(0, y);
    // Правая диагональ
    ctx.moveTo(25 * scale, -5 * scale);
    ctx.lineTo(0, y);
    // Дополнительные диагонали
    ctx.moveTo(-20 * scale, 10 * scale);
    ctx.lineTo(10 * scale, -15 * scale);
    ctx.moveTo(20 * scale, 10 * scale);
    ctx.lineTo(-10 * scale, -15 * scale);
  }
  
  // Основные крылья с кривыми
  ctx.moveTo(-18 * scale, 5 * scale);
  ctx.bezierCurveTo(-28 * scale, 2 * scale, -38 * scale, 0 * scale, -45 * scale, -2 * scale);
  ctx.bezierCurveTo(-44 * scale, 5 * scale, -40 * scale, 10 * scale, -42 * scale, 12 * scale);
  ctx.bezierCurveTo(-35 * scale, 12 * scale, -25 * scale, 10 * scale, -18 * scale, 12 * scale);
  ctx.closePath();
  
  ctx.moveTo(18 * scale, 5 * scale);
  ctx.bezierCurveTo(28 * scale, 2 * scale, 38 * scale, 0 * scale, 45 * scale, -2 * scale);
  ctx.bezierCurveTo(44 * scale, 5 * scale, 40 * scale, 10 * scale, 42 * scale, 12 * scale);
  ctx.bezierCurveTo(35 * scale, 12 * scale, 25 * scale, 10 * scale, 18 * scale, 12 * scale);
  ctx.closePath();
  
  // Структурные линии на крыльях (очень плотная сетка)
  for (let i = 0; i <= 1; i += 0.08) {
    const x1 = -18 + (-27) * i;
    const y1 = 5 + (-7) * i;
    const x2 = -18 + (-24) * i;
    const y2 = 5 + 7 * i;
    ctx.moveTo(x1 * scale, y1 * scale);
    ctx.lineTo(x2 * scale, y2 * scale);
    
    const x3 = 18 + 27 * i;
    const y3 = 5 + (-7) * i;
    const x4 = 18 + 24 * i;
    const y4 = 5 + 7 * i;
    ctx.moveTo(x3 * scale, y3 * scale);
    ctx.lineTo(x4 * scale, y4 * scale);
  }
  
  // Хвостовое оперение с кривыми
  ctx.moveTo(-8 * scale, 22 * scale);
  ctx.bezierCurveTo(-10 * scale, 26 * scale, -13 * scale, 30 * scale, -15 * scale, 32 * scale);
  ctx.lineTo(-5 * scale, 28 * scale);
  ctx.bezierCurveTo(-3 * scale, 26 * scale, -2 * scale, 24 * scale, 0, 22 * scale);
  ctx.moveTo(8 * scale, 22 * scale);
  ctx.bezierCurveTo(10 * scale, 26 * scale, 13 * scale, 30 * scale, 15 * scale, 32 * scale);
  ctx.lineTo(5 * scale, 28 * scale);
  ctx.bezierCurveTo(3 * scale, 26 * scale, 2 * scale, 24 * scale, 0, 22 * scale);
  
  // Вертикальный стабилизатор
  ctx.moveTo(0, 22 * scale);
  ctx.bezierCurveTo(1 * scale, 28 * scale, 0.5 * scale, 32 * scale, 0, 35 * scale);
  ctx.bezierCurveTo(-3 * scale, 33 * scale, -5 * scale, 31 * scale, -6 * scale, 32 * scale);
  ctx.bezierCurveTo(-4 * scale, 30 * scale, -2 * scale, 28 * scale, 0, 26 * scale);
  ctx.bezierCurveTo(2 * scale, 28 * scale, 4 * scale, 30 * scale, 6 * scale, 32 * scale);
  ctx.bezierCurveTo(5 * scale, 31 * scale, 3 * scale, 33 * scale, 0, 35 * scale);
  
  // Структурные линии на стабилизаторе (очень плотная сетка)
  for (let i = 0; i <= 1; i += 0.1) {
    const y = 22 + 13 * i;
    const width = 6 * (1 - i * 0.8);
    ctx.moveTo(-width * scale, y * scale);
    ctx.lineTo(width * scale, y * scale);
  }
  
  // Кабина пилота - детализированная с кривыми
  ctx.moveTo(-8 * scale, -15 * scale);
  ctx.bezierCurveTo(-9 * scale, -12 * scale, -10 * scale, -9 * scale, -10 * scale, -8 * scale);
  ctx.bezierCurveTo(-5 * scale, -6 * scale, 5 * scale, -6 * scale, 10 * scale, -8 * scale);
  ctx.bezierCurveTo(10 * scale, -9 * scale, 9 * scale, -12 * scale, 8 * scale, -15 * scale);
  ctx.closePath();
  
  // Перегородки в кабине (очень плотная сетка)
  for (let i = -7; i <= 7; i += 1.2) {
    ctx.moveTo(i * scale, -15 * scale);
    ctx.lineTo(i * scale, -8 * scale);
  }
  
  // Дополнительные структурные линии в кабине (очень плотная сетка)
  for (let i = -13; i <= -7; i += 0.8) {
    const y = i * scale;
    const width = 8 - Math.abs(i + 10) * 0.3;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // Двигатели - более детальные
  ctx.moveTo(-20 * scale, 18 * scale);
  ctx.bezierCurveTo(-22 * scale, 21 * scale, -24 * scale, 23 * scale, -25 * scale, 25 * scale);
  ctx.lineTo(-15 * scale, 25 * scale);
  ctx.bezierCurveTo(-16 * scale, 23 * scale, -18 * scale, 21 * scale, -20 * scale, 18 * scale);
  
  ctx.moveTo(20 * scale, 18 * scale);
  ctx.bezierCurveTo(22 * scale, 21 * scale, 24 * scale, 23 * scale, 25 * scale, 25 * scale);
  ctx.lineTo(15 * scale, 25 * scale);
  ctx.bezierCurveTo(16 * scale, 23 * scale, 18 * scale, 21 * scale, 20 * scale, 18 * scale);
  
  // Структурные линии на двигателях (очень плотная сетка)
  for (let i = 0; i <= 1; i += 0.15) {
    const y = 18 + 7 * i;
    const width = 5 * (1 - i * 0.5);
    ctx.moveTo((-20 - width) * scale, y * scale);
    ctx.lineTo((-20 + width) * scale, y * scale);
    
    ctx.moveTo((20 - width) * scale, y * scale);
    ctx.lineTo((20 + width) * scale, y * scale);
  }
  
  // Сопла двигателей
  ctx.moveTo(-20 * scale, 25 * scale);
  ctx.bezierCurveTo(-21 * scale, 26 * scale, -22 * scale, 27 * scale, -22 * scale, 28 * scale);
  ctx.lineTo(-18 * scale, 28 * scale);
  ctx.bezierCurveTo(-19 * scale, 27 * scale, -20 * scale, 26 * scale, -20 * scale, 25 * scale);
  
  ctx.moveTo(20 * scale, 25 * scale);
  ctx.bezierCurveTo(21 * scale, 26 * scale, 22 * scale, 27 * scale, 22 * scale, 28 * scale);
  ctx.lineTo(18 * scale, 28 * scale);
  ctx.bezierCurveTo(19 * scale, 27 * scale, 20 * scale, 26 * scale, 20 * scale, 25 * scale);
  
  // Орудия на крыльях
  ctx.moveTo(-40 * scale, 0 * scale);
  ctx.bezierCurveTo(-42 * scale, -2 * scale, -43 * scale, -3 * scale, -44 * scale, -4 * scale);
  ctx.lineTo(-44 * scale, 4 * scale);
  ctx.bezierCurveTo(-43 * scale, 3 * scale, -42 * scale, 2 * scale, -40 * scale, 0 * scale);
  
  ctx.moveTo(40 * scale, 0 * scale);
  ctx.bezierCurveTo(42 * scale, -2 * scale, 43 * scale, -3 * scale, 44 * scale, -4 * scale);
  ctx.lineTo(44 * scale, 4 * scale);
  ctx.bezierCurveTo(43 * scale, 3 * scale, 42 * scale, 2 * scale, 40 * scale, 0 * scale);
  
  // Дополнительные детали
  // Технологические порты и вентиляционные отверстия
  for (let i = -15; i <= 15; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    const size = 2 * scale;
    ctx.moveTo(x - size, 5 * scale);
    ctx.lineTo(x + size, 5 * scale);
    ctx.moveTo(x, 5 * scale - size);
    ctx.lineTo(x, 5 * scale + size);
  }
  
  // Панели управления и сенсоры (очень плотная сетка)
  for (let i = -12; i <= 12; i += 3) {
    const x = i * scale;
    // Панели на корпусе
    ctx.moveTo(x - 1.5 * scale, -8 * scale);
    ctx.lineTo(x + 1.5 * scale, -8 * scale);
    ctx.moveTo(x - 1.5 * scale, -10 * scale);
    ctx.lineTo(x + 1.5 * scale, -10 * scale);
    
    // Сенсорные массивы
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x, 11 * scale);
    ctx.lineTo(x, 13 * scale);
  }
  
  // Системы охлаждения (очень плотная сетка)
  for (let i = -22; i <= 22; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, 15 * scale);
    ctx.lineTo(x + 2 * scale, 15 * scale);
    ctx.moveTo(x - 2 * scale, 17 * scale);
    ctx.lineTo(x + 2 * scale, 17 * scale);
  }
  
  // Дополнительные орудия и системы вооружения
  for (let i = -35; i <= 35; i += 20) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, -2 * scale);
    ctx.lineTo(x + 1.5 * scale, -2 * scale);
    ctx.moveTo(x - 1.5 * scale, 2 * scale);
    ctx.lineTo(x + 1.5 * scale, 2 * scale);
    ctx.moveTo(x, -2 * scale);
    ctx.lineTo(x, 2 * scale);
  }
  
  ctx.stroke();
  
  // Дополнительные детали с другим цветом/толщиной
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.7;
  
  ctx.beginPath();
  // Декоративные панели на корпусе (очень плотная сетка)
  for (let i = -25; i <= 25; i += 1.5) {
    if (i === 0) continue;
    const x = i * scale;
    const height = 20 - Math.abs(i) * 0.4;
    ctx.moveTo(x, -height * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // Кольца на носовой части (очень плотная сетка)
  for (let i = 1; i <= 12; i++) {
    const radius = i * 1.5 * scale;
    ctx.moveTo(-radius, -20 * scale + i * 1.0);
    ctx.lineTo(radius, -20 * scale + i * 1.0);
  }
  
  // Сложные технологические линии с кривыми
  for (let i = -20; i <= 20; i += 4) {
    const x = i * scale;
    const curveHeight = 8 * Math.sin(i * 0.15);
    ctx.moveTo(x, -15 * scale);
    ctx.bezierCurveTo(
      x, -10 * scale + curveHeight,
      x, -5 * scale - curveHeight,
      x, 5 * scale
    );
  }
  
  // Схемы проводки (очень плотная сетка)
  for (let i = -18; i <= 18; i += 4) {
    const x = i * scale;
    ctx.moveTo(x, -5 * scale);
    ctx.bezierCurveTo(
      x - 2 * scale, 0,
      x + 2 * scale, 5 * scale,
      x, 10 * scale
    );
  }
  
  // Дополнительные сенсорные решетки
  for (let i = -10; i <= 10; i += 5) {
    const x = i * scale;
    for (let j = -12; j <= -8; j += 1) {
      const y = j * scale;
      ctx.moveTo(x - 1 * scale, y);
      ctx.lineTo(x + 1 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // Свечение двигателей
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.5;
  
  ctx.beginPath();
  // Импульсы от двигателей
  for (let i = 1; i <= 12; i++) {
    const length = 4 + i * 1.2;
    const spread = i * 0.4;
    ctx.moveTo(-20 * scale - spread, 28 * scale);
    ctx.lineTo(-20 * scale - spread, 28 * scale + length);
    ctx.moveTo(-20 * scale + spread, 28 * scale);
    ctx.lineTo(-20 * scale + spread, 28 * scale + length);
    
    ctx.moveTo(20 * scale - spread, 28 * scale);
    ctx.lineTo(20 * scale - spread, 28 * scale + length);
    ctx.moveTo(20 * scale + spread, 28 * scale);
    ctx.lineTo(20 * scale + spread, 28 * scale + length);
  }
  
  ctx.stroke();
  
  ctx.restore();
}

// Рисование корабля типа 2 - Крейсер (ультра детализированный)
function drawShipCruiser(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180 * 0.7); // Меньше качание для большого корабля
  
  const scale = 1.5; // Больше размер
  const enginePulse = Math.abs(Math.sin(t * 0.008)) * 0.5 + 0.5;
  
  const mainColor = primaryColor;
  const engineColor = `rgba(255, 150, 50, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // Меньше прозрачности (93%)
  
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // Массивный корпус крейсера
    ctx.moveTo(0, -18 * scale);
    ctx.bezierCurveTo(-12 * scale, -16 * scale, -25 * scale, -12 * scale, -35 * scale, -12 * scale);
    ctx.bezierCurveTo(-38 * scale, -8 * scale, -40 * scale, 0 * scale, -40 * scale, 5 * scale);
    ctx.bezierCurveTo(-38 * scale, 15 * scale, -32 * scale, 22 * scale, -30 * scale, 25 * scale);
    ctx.lineTo(-15 * scale, 30 * scale);
    ctx.lineTo(15 * scale, 30 * scale);
    ctx.lineTo(30 * scale, 25 * scale);
    ctx.bezierCurveTo(32 * scale, 22 * scale, 38 * scale, 15 * scale, 40 * scale, 5 * scale);
    ctx.bezierCurveTo(40 * scale, 0 * scale, 38 * scale, -8 * scale, 35 * scale, -12 * scale);
    ctx.bezierCurveTo(25 * scale, -12 * scale, 12 * scale, -16 * scale, 0, -18 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // Основной корпус
  ctx.moveTo(0, -18 * scale);
  ctx.bezierCurveTo(-12 * scale, -16 * scale, -25 * scale, -12 * scale, -35 * scale, -12 * scale);
  ctx.bezierCurveTo(-38 * scale, -8 * scale, -40 * scale, 0 * scale, -40 * scale, 5 * scale);
  ctx.bezierCurveTo(-38 * scale, 15 * scale, -32 * scale, 22 * scale, -30 * scale, 25 * scale);
  ctx.lineTo(-15 * scale, 30 * scale);
  ctx.lineTo(15 * scale, 30 * scale);
  ctx.lineTo(30 * scale, 25 * scale);
  ctx.bezierCurveTo(32 * scale, 22 * scale, 38 * scale, 15 * scale, 40 * scale, 5 * scale);
  ctx.bezierCurveTo(40 * scale, 0 * scale, 38 * scale, -8 * scale, 35 * scale, -12 * scale);
  ctx.bezierCurveTo(25 * scale, -12 * scale, 12 * scale, -16 * scale, 0, -18 * scale);
  
  // Центральная линия
  ctx.moveTo(0, -18 * scale);
  ctx.lineTo(0, 30 * scale);
  
  // Горизонтальные структурные линии (очень плотная сетка)
  for (let i = -15; i <= 30; i += 1.5) {
    const y = i * scale;
    if (y > 30 * scale) continue;
    const width = 35 - Math.abs(i + 5) * 0.5;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // Мостик
  ctx.moveTo(-12 * scale, -10 * scale);
  ctx.lineTo(12 * scale, -10 * scale);
  ctx.lineTo(15 * scale, -5 * scale);
  ctx.lineTo(-15 * scale, -5 * scale);
  ctx.closePath();
  
  // Большие двигатели
  ctx.moveTo(-20 * scale, 30 * scale);
  ctx.bezierCurveTo(-22 * scale, 33 * scale, -24 * scale, 36 * scale, -25 * scale, 40 * scale);
  ctx.lineTo(-15 * scale, 40 * scale);
  ctx.bezierCurveTo(-16 * scale, 36 * scale, -18 * scale, 33 * scale, -20 * scale, 30 * scale);
  
  ctx.moveTo(20 * scale, 30 * scale);
  ctx.bezierCurveTo(22 * scale, 33 * scale, 24 * scale, 36 * scale, 25 * scale, 40 * scale);
  ctx.lineTo(15 * scale, 40 * scale);
  ctx.bezierCurveTo(16 * scale, 36 * scale, 18 * scale, 33 * scale, 20 * scale, 30 * scale);
  
  // Дополнительные двигатели
  ctx.moveTo(-8 * scale, 30 * scale);
  ctx.bezierCurveTo(-10 * scale, 33 * scale, -11 * scale, 35 * scale, -12 * scale, 38 * scale);
  ctx.lineTo(-4 * scale, 38 * scale);
  ctx.bezierCurveTo(-5 * scale, 35 * scale, -6 * scale, 33 * scale, -8 * scale, 30 * scale);
  
  ctx.moveTo(8 * scale, 30 * scale);
  ctx.bezierCurveTo(10 * scale, 33 * scale, 11 * scale, 35 * scale, 12 * scale, 38 * scale);
  ctx.lineTo(4 * scale, 38 * scale);
  ctx.bezierCurveTo(5 * scale, 35 * scale, 6 * scale, 33 * scale, 8 * scale, 30 * scale);
  
  // Антенны и сенсоры (очень плотная сетка)
  ctx.moveTo(-5 * scale, -18 * scale);
  ctx.lineTo(-8 * scale, -25 * scale);
  ctx.moveTo(5 * scale, -18 * scale);
  ctx.lineTo(8 * scale, -25 * scale);
  ctx.moveTo(0, -18 * scale);
  ctx.lineTo(0, -22 * scale);
  
  // Дополнительные антенны
  for (let i = -10; i <= 10; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x, -18 * scale);
    ctx.lineTo(x, -21 * scale);
  }
  
  // Орудийные башни (очень плотная сетка)
  for (let i = -25; i <= 25; i += 8) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 3 * scale, 8 * scale);
    ctx.lineTo(x + 3 * scale, 8 * scale);
    ctx.moveTo(x - 3 * scale, 12 * scale);
    ctx.lineTo(x + 3 * scale, 12 * scale);
    ctx.moveTo(x, 8 * scale);
    ctx.lineTo(x, 12 * scale);
    
    // Дополнительные орудия
    ctx.moveTo(x - 2 * scale, 5 * scale);
    ctx.lineTo(x + 2 * scale, 5 * scale);
    ctx.moveTo(x - 2 * scale, 15 * scale);
    ctx.lineTo(x + 2 * scale, 15 * scale);
  }
  
  // Шлюзовые отсеки (очень плотная сетка)
  for (let i = -20; i <= 20; i += 10) {
    const x = i * scale;
    ctx.moveTo(x - 4 * scale, 18 * scale);
    ctx.lineTo(x + 4 * scale, 18 * scale);
    ctx.moveTo(x - 4 * scale, 22 * scale);
    ctx.lineTo(x + 4 * scale, 22 * scale);
    
    // Дополнительные шлюзы
    ctx.moveTo(x - 3 * scale, 20 * scale);
    ctx.lineTo(x + 3 * scale, 20 * scale);
  }
  
  // Дополнительные структурные элементы
  for (let i = -30; i <= 30; i += 15) {
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, -5 * scale);
    ctx.lineTo(x + 2 * scale, -5 * scale);
    ctx.moveTo(x - 2 * scale, 25 * scale);
    ctx.lineTo(x + 2 * scale, 25 * scale);
  }
  
  ctx.stroke();
  
  // Детали с акцентным цветом
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.7;
  
  ctx.beginPath();
  
  // Панели на корпусе (очень плотная сетка)
  for (let i = -30; i <= 30; i += 2) {
    if (i === 0) continue;
    const x = i * scale;
    const height = 25 - Math.abs(i) * 0.3;
    ctx.moveTo(x, -15 * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // Окна на мостике (очень плотная сетка)
  for (let i = -10; i <= 10; i += 1.5) {
    ctx.moveTo(i * scale, -8 * scale);
    ctx.lineTo(i * scale, -6 * scale);
  }
  
  // Технологические панели (очень плотная сетка)
  for (let i = -28; i <= 28; i += 7) {
    const x = i * scale;
    for (let j = 5; j <= 20; j += 3) {
      const y = j * scale;
      ctx.moveTo(x - 2 * scale, y);
      ctx.lineTo(x + 2 * scale, y);
    }
  }
  
  // Системы вентиляции (очень плотная сетка)
  for (let i = -32; i <= 32; i += 8) {
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, 2 * scale);
    ctx.lineTo(x + 1.5 * scale, 2 * scale);
    ctx.moveTo(x - 1.5 * scale, 4 * scale);
    ctx.lineTo(x + 1.5 * scale, 4 * scale);
  }
  
  // Дополнительные сенсорные массивы
  for (let i = -15; i <= 15; i += 10) {
    const x = i * scale;
    for (let j = -12; j <= -8; j += 1) {
      const y = j * scale;
      ctx.moveTo(x - 1 * scale, y);
      ctx.lineTo(x + 1 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // Двигатели
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.5;
  
  ctx.beginPath();
  
  for (let i = 1; i <= 8; i++) {
    const length = 8 + i * 1.5;
    const spread = i * 0.7;
    // Основные двигатели
    ctx.moveTo(-22 * scale - spread, 40 * scale);
    ctx.lineTo(-22 * scale - spread, 40 * scale + length);
    ctx.moveTo(-22 * scale + spread, 40 * scale);
    ctx.lineTo(-22 * scale + spread, 40 * scale + length);
    
    ctx.moveTo(22 * scale - spread, 40 * scale);
    ctx.lineTo(22 * scale - spread, 40 * scale + length);
    ctx.moveTo(22 * scale + spread, 40 * scale);
    ctx.lineTo(22 * scale + spread, 40 * scale + length);
    
    // Вспомогательные двигатели
    ctx.moveTo(-10 * scale, 38 * scale);
    ctx.lineTo(-10 * scale, 38 * scale + length * 0.7);
    ctx.moveTo(10 * scale, 38 * scale);
    ctx.lineTo(10 * scale, 38 * scale + length * 0.7);
  }
  
  ctx.stroke();
  ctx.restore();
}

// Рисование корабля типа 3 - Разведчик (ультра детализированный)
function drawShipScout(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180 * 1.3); // Больше качание для маленького корабля
  
  const scale = 0.9; // Меньше размер
  const enginePulse = Math.abs(Math.sin(t * 0.015)) * 0.5 + 0.5;
  
  const mainColor = primaryColor;
  const engineColor = `rgba(50, 200, 255, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // Меньше прозрачности (93%)
  
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // Обтекаемая форма разведчика
    ctx.moveTo(0, -25 * scale);
    ctx.bezierCurveTo(-12 * scale, -22 * scale, -20 * scale, -15 * scale, -22 * scale, -5 * scale);
    ctx.bezierCurveTo(-25 * scale, 8 * scale, -18 * scale, 18 * scale, -10 * scale, 22 * scale);
    ctx.lineTo(10 * scale, 22 * scale);
    ctx.bezierCurveTo(18 * scale, 18 * scale, 25 * scale, 8 * scale, 22 * scale, -5 * scale);
    ctx.bezierCurveTo(20 * scale, -15 * scale, 12 * scale, -22 * scale, 0, -25 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // Основной корпус
  ctx.moveTo(0, -25 * scale);
  ctx.bezierCurveTo(-12 * scale, -22 * scale, -20 * scale, -15 * scale, -22 * scale, -5 * scale);
  ctx.bezierCurveTo(-25 * scale, 8 * scale, -18 * scale, 18 * scale, -10 * scale, 22 * scale);
  ctx.lineTo(10 * scale, 22 * scale);
  ctx.bezierCurveTo(18 * scale, 18 * scale, 25 * scale, 8 * scale, 22 * scale, -5 * scale);
  ctx.bezierCurveTo(20 * scale, -15 * scale, 12 * scale, -22 * scale, 0, -25 * scale);
  
  // Центральная линия
  ctx.moveTo(0, -25 * scale);
  ctx.lineTo(0, 22 * scale);
  
  // Горизонтальные структурные линии (очень плотная сетка)
  for (let i = -22; i <= 22; i += 2) {
    const y = i * scale;
    const width = 20 - Math.abs(i) * 0.4;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // Сенсорные панели
  ctx.moveTo(-15 * scale, -10 * scale);
  ctx.bezierCurveTo(-20 * scale, -12 * scale, -23 * scale, -14 * scale, -25 * scale, -15 * scale);
  ctx.bezierCurveTo(-24 * scale, -10 * scale, -23 * scale, -7 * scale, -22 * scale, -5 * scale);
  
  ctx.moveTo(15 * scale, -10 * scale);
  ctx.bezierCurveTo(20 * scale, -12 * scale, 23 * scale, -14 * scale, 25 * scale, -15 * scale);
  ctx.bezierCurveTo(24 * scale, -10 * scale, 23 * scale, -7 * scale, 22 * scale, -5 * scale);
  
  // Антенны (очень плотная сетка)
  ctx.moveTo(-8 * scale, -20 * scale);
  ctx.lineTo(-12 * scale, -28 * scale);
  ctx.moveTo(8 * scale, -20 * scale);
  ctx.lineTo(12 * scale, -28 * scale);
  ctx.moveTo(0, -25 * scale);
  ctx.lineTo(0, -32 * scale);
  
  // Дополнительные антенны (очень плотная сетка)
  ctx.moveTo(-5 * scale, -22 * scale);
  ctx.lineTo(-8 * scale, -30 * scale);
  ctx.moveTo(5 * scale, -22 * scale);
  ctx.lineTo(8 * scale, -30 * scale);
  
  // Еще больше антенн
  for (let i = -3; i <= 3; i += 3) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x, -23 * scale);
    ctx.lineTo(x, -26 * scale);
  }
  
  // Двигатели
  ctx.moveTo(-8 * scale, 22 * scale);
  ctx.bezierCurveTo(-10 * scale, 25 * scale, -11 * scale, 27 * scale, -12 * scale, 30 * scale);
  ctx.lineTo(-4 * scale, 30 * scale);
  ctx.bezierCurveTo(-5 * scale, 27 * scale, -6 * scale, 25 * scale, -8 * scale, 22 * scale);
  
  ctx.moveTo(8 * scale, 22 * scale);
  ctx.bezierCurveTo(10 * scale, 25 * scale, 11 * scale, 27 * scale, 12 * scale, 30 * scale);
  ctx.lineTo(4 * scale, 30 * scale);
  ctx.bezierCurveTo(5 * scale, 27 * scale, 6 * scale, 25 * scale, 8 * scale, 22 * scale);
  
  // Сенсорные массивы (очень плотная сетка)
  for (let i = -18; i <= 18; i += 6) {
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, -5 * scale);
    ctx.lineTo(x + 2 * scale, -5 * scale);
    ctx.moveTo(x - 2 * scale, -8 * scale);
    ctx.lineTo(x + 2 * scale, -8 * scale);
  }
  
  // Коммуникационные панели (очень плотная сетка)
  for (let i = -15; i <= 15; i += 5) {
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, 5 * scale);
    ctx.lineTo(x + 1.5 * scale, 5 * scale);
    ctx.moveTo(x - 1.5 * scale, 8 * scale);
    ctx.lineTo(x + 1.5 * scale, 8 * scale);
  }
  
  // Системы навигации
  ctx.moveTo(-3 * scale, -18 * scale);
  ctx.lineTo(-6 * scale, -15 * scale);
  ctx.moveTo(3 * scale, -18 * scale);
  ctx.lineTo(6 * scale, -15 * scale);
  
  // Дополнительные сенсоры
  for (let i = -10; i <= 10; i += 10) {
    const x = i * scale;
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x - 1 * scale, 15 * scale);
    ctx.lineTo(x + 1 * scale, 15 * scale);
  }
  
  ctx.stroke();
  
  // Детали с акцентным цветом
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.6;
  
  ctx.beginPath();
  
  // Сенсорные решетки (очень плотная сетка)
  for (let i = -18; i <= 18; i += 2) {
    const x = i * scale;
    const curve = Math.sin(i * 0.3) * 3;
    const height = 20 - Math.abs(i) * 0.4 + curve;
    ctx.moveTo(x, -20 * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // Панели управления (очень плотная сетка)
  for (let i = -12; i <= 12; i += 3) {
    const x = i * scale;
    // Вертикальные панели
    ctx.moveTo(x, -12 * scale);
    ctx.lineTo(x, -8 * scale);
    // Горизонтальные панели
    ctx.moveTo(x - 1.5 * scale, -10 * scale);
    ctx.lineTo(x + 1.5 * scale, -10 * scale);
  }
  
  // Технологические порты (очень плотная сетка)
  for (let i = -16; i <= 16; i += 8) {
    const x = i * scale;
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x - 1 * scale, 15 * scale);
    ctx.lineTo(x + 1 * scale, 15 * scale);
  }
  
  // Дополнительные детали
  for (let i = -14; i <= 14; i += 14) {
    const x = i * scale;
    for (let j = -5; j <= 5; j += 5) {
      const y = j * scale;
      ctx.moveTo(x - 0.5 * scale, y);
      ctx.lineTo(x + 0.5 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // Двигатели
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.3;
  
  ctx.beginPath();
  
  for (let i = 1; i <= 6; i++) {
    const length = 5 + i * 1.2;
    const spread = i * 0.3;
    ctx.moveTo(-8 * scale - spread, 30 * scale);
    ctx.lineTo(-8 * scale - spread, 30 * scale + length);
    ctx.moveTo(-8 * scale + spread, 30 * scale);
    ctx.lineTo(-8 * scale + spread, 30 * scale + length);
    
    ctx.moveTo(8 * scale - spread, 30 * scale);
    ctx.lineTo(8 * scale - spread, 30 * scale + length);
    ctx.moveTo(8 * scale + spread, 30 * scale);
    ctx.lineTo(8 * scale + spread, 30 * scale + length);
  }
  
  ctx.stroke();
  ctx.restore();
}

// Функция проверки столкновения
function checkCollision() {
  if (!UI.gameMode || Game.crashed) return false;
  
  // Проверяем столкновение с ближайшим рядом ландшафта
  const nearestRow = grid[5]; // Ближайший видимый ряд
  const shipWorldX = Game.shipX * 0.1; // Масштабируем позицию корабля
  
  // Находим сегмент, соответствующий позиции корабля
  const segmentIndex = Math.floor((shipWorldX / 1200 + 0.5) * segments);
  
  if (segmentIndex >= 0 && segmentIndex < nearestRow.length) {
    const terrainHeight = nearestRow[segmentIndex].y;
    // Если высота terrainHeight больше определенного порога - столкновение
    if (terrainHeight > 30) {
      Game.crashed = true;
      return true;
    }
  }
  
  return false;
}

// main draw loop
let lastT = 0;
function draw(t){
  if(!lastT) lastT = t;
  const dt = Math.min(50, t - lastT) / 1000; lastT = t;
  
  if(!paused) {
    timeOffset += dt * UI.speed * 1.0;
    
    // Обновление игрового состояния
    if (UI.gameMode && !Game.crashed) {
      Game.distance += UI.speed * dt * 100;
      
      // Управление кораблем
      const moveSpeed = 200 * dt;
      if (Game.keys.left) Game.shipX -= moveSpeed;
      if (Game.keys.right) Game.shipX += moveSpeed;
      
      // Ограничение перемещения
      Game.shipX = Math.max(-400, Math.min(400, Game.shipX));
      
      // Проверка столкновения
      checkCollision();
      
      // Обновление UI игры
      $('gameSpeed').textContent = Math.round(UI.speed * 100);
      $('gameDistance').textContent = Math.round(Game.distance);
      $('gameStatus').textContent = Game.crashed ? '💥 СТОЛКНОВЕНИЕ!' : '✅ В полёте';
      $('gameStatus').style.color = Game.crashed ? '#ff5555' : '#55ff55';
    }
  }

  // clear
  ctx.clearRect(0,0,innerWidth,innerHeight);
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,innerHeight);
  g.addColorStop(0,'#020418'); g.addColorStop(1,'#000006');
  ctx.fillStyle = g; ctx.fillRect(0,0,innerWidth,innerHeight);

  // camera
  const camera = {
    x: 0,
    y: 60, // увеличили высоту камеры для более высоких пиков
    z: -50,
    pitch: UI.pitch * Math.PI/180,
    fov: UI.fov,
    cx: innerWidth/2,
    cy: innerHeight * 0.45
  };

  // generate terrain heights procedurally for each grid point
  const widthWorld = 1200;
  for(let d=0; d<depthSteps; d++){
    const z = d / (depthSteps-1) * 1200;
    for(let s=0; s<=segments; s++){
      const x = (s / segments - 0.5) * widthWorld;
      const nx = x * (UI.freq * 0.002);
      const nz = (z * 0.002) + timeOffset * UI.speed * 0.1;
      // fbm noise с более острыми пиками
      const h = fbm(nx, nz, 6, 2.2, 0.45); // больше октав, другой lacunarity/gain
      const y = (h - 0.3) * UI.amplitude * 2.5; // увеличен множитель для более высоких пиков
      grid[d][s].x = x; grid[d][s].y = y; grid[d][s].z = z;
    }
  }

  // drawing lines: far to near
  ctx.lineWidth = UI.lineWidth;
  ctx.globalAlpha = 1.0;

  // contours (rows)
  for(let d=depthSteps-1; d>=0; d--){
    const depthRatio = d / depthSteps;
    ctx.strokeStyle = getGradientColor(UI.color, depthRatio);
    ctx.beginPath();
    let firstValid = false;
    for(let s=0; s<=segments; s++){
      const p = grid[d][s];
      const proj = projectPoint(p.x, p.y, p.z, camera);
      if(!proj) continue;
      if(!firstValid){ ctx.moveTo(proj.sx, proj.sy); firstValid = true; }
      else ctx.lineTo(proj.sx, proj.sy);
    }
    ctx.stroke();
  }

  // optional vertical grid lines (columns)
  if(UI.showGrid){
    for(let s=0; s<=segments; s+=Math.max(1,Math.floor(segments/80))){
      const depthRatio = s / segments;
      ctx.strokeStyle = getGradientColor(UI.color, depthRatio);
      ctx.beginPath();
      let first=false;
      for(let d=0; d<depthSteps; d++){
        const p = grid[d][s];
        const proj = projectPoint(p.x, p.y, p.z, camera);
        if(!proj) continue;
        if(!first){ ctx.moveTo(proj.sx, proj.sy); first=true; }
        else ctx.lineTo(proj.sx, proj.sy);
      }
      ctx.stroke();
    }
  }

  // draw ship based on selected type
  const shipBaseX = innerWidth/2;
  const shipBaseY = innerHeight * 0.76;
  const wobble = UI.shipWobble ? Math.sin(t*0.0025 * UI.speed) * 8 : 0;
  const bob = UI.shipWobble ? Math.sin(t*0.004 * UI.speed) * 6 : 0;
  
  // Выбор корабля в зависимости от типа
  switch(UI.shipType) {
    case '1':
      drawShipFighter(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
    case '2':
      drawShipCruiser(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
    case '3':
      drawShipScout(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
  }

  // HUD horizon line subtle
  ctx.globalAlpha = 0.06;
  ctx.beginPath(); ctx.moveTo(0, camera.cy); ctx.lineTo(innerWidth, camera.cy); ctx.stroke(); ctx.globalAlpha = 1.0;

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

// initial sync UI values
function syncUI(){
  $('speed').value = UI.speed;
  $('amplitude').value = UI.amplitude;
  $('freq').value = UI.freq;
  $('pitch').value = UI.pitch;
  $('fov').value = UI.fov;
  $('segments').value = UI.segments;
  $('depth').value = UI.depth;
  $('lineWidth').value = UI.lineWidth;
  $('color').value = UI.color;
  $('shipType').value = UI.shipType;
  $('shipColor').value = UI.shipColor;
  $('shipAccentColor').value = UI.shipAccentColor;
  $('showGrid').checked = UI.showGrid;
  $('shipWobble').checked = UI.shipWobble;
  $('shipFill').checked = UI.shipFill;
  $('gradientColor').checked = UI.gradientColor;
  $('gameMode').checked = UI.gameMode;
}
syncUI();

// keep canvas resized properly
setInterval(()=>{ resize(); }, 500);

</script>
</body>
</html>
