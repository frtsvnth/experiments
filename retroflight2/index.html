<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro Pseudo-3D Flight ‚Äî Wireframe Terrain</title>
<style>
:root{
  --bg:#050613;
  --panel: rgba(6,10,20,0.7);
  --accent:#33ffdd;
  --muted:#9aa7c9;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial}
canvas{display:block;width:100vw;height:100vh}
.ui{
  position:fixed;right:16px;top:16px;width:340px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  transition: transform 0.3s ease, opacity 0.3s ease;
}
.ui.hidden{
  transform: translateX(100%);
  opacity: 0;
  pointer-events: none;
}
.ui-toggle{
  position:fixed;right:16px;top:16px;width:44px;height:44px;border-radius:50%;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all 0.3s ease;z-index:1000;
}
.ui-toggle:hover{
  transform: scale(1.1);
}
.ui-toggle.hidden{
  opacity: 0;
  pointer-events: none;
}
.ui h3{margin:0 0 10px 0;color:var(--accent);font-size:16px}
.row{display:flex;align-items:center;gap:8px;margin:8px 0}
.row label{flex:1;font-size:13px}
.row input[type=range]{flex:2}
.row input[type=color]{width:44px;height:30px;border-radius:6px;border:1px solid rgba(255,255,255,0.06)}
.row select{flex:2;padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(0,0,0,0.5);color:var(--muted)}
.controls{display:flex;gap:8px;margin-top:8px}
.controls button{flex:1;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:var(--muted);cursor:pointer}
.checkbox{display:flex;align-items:center;gap:8px}
.small{font-size:12px;color:#6f7ba6}
.game-info{
  position:fixed;left:16px;top:16px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(8,12,22,0.88),rgba(2,4,8,0.7));color:var(--muted);backdrop-filter:blur(6px);border:1px solid rgba(255,255,255,0.04);box-shadow:0 8px 30px rgba(0,0,0,0.6);
  font-size:13px;display:none;
}
.game-info.active{display:block;}
@media (max-width:420px){.ui{left:6px;right:6px;width:auto}}
</style>
</head>
<body>
<canvas id="cnv"></canvas>
<div class="ui" id="ui">
  <h3>Retro Flight ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–ø—Å–µ–≤–¥–æ‚Äë3D)</h3>
  <div class="row"><label>–ú–æ–¥–µ–ª—å –∫–æ—Ä–∞–±–ª—è</label>
    <select id="shipType">
      <option value="1">–ò—Å—Ç—Ä–µ–±–∏—Ç–µ–ª—å</option>
      <option value="2">–ö—Ä–µ–π—Å–µ—Ä</option>
      <option value="3">–†–∞–∑–≤–µ–¥—á–∏–∫</option>
    </select>
  </div>
  <div class="row"><label>–¶–≤–µ—Ç –∫–æ—Ä–∞–±–ª—è (–æ—Å–Ω–æ–≤–Ω–æ–π)</label><input id="shipColor" type="color" value="#33ffdd"></div>
  <div class="row"><label>–¶–≤–µ—Ç –∫–æ—Ä–∞–±–ª—è (–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π)</label><input id="shipAccentColor" type="color" value="#aaffff"></div>
  <div class="row"><label>–°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–ª—ë—Ç–∞</label><input id="speed" type="range" min="0" max="3" step="0.01" value="1"></div>
  <div class="row"><label>–í—ã—Å–æ—Ç–∞ —Ä–µ–ª—å–µ—Ñ–∞</label><input id="amplitude" type="range" min="5" max="500" step="1" value="120"></div>
  <div class="row"><label>–ß–∞—Å—Ç–æ—Ç–∞ —à—É–º–∞</label><input id="freq" type="range" min="0.2" max="6" step="0.01" value="1.5"></div>
  <div class="row"><label>–£–≥–æ–ª –∫–∞–º–µ—Ä—ã (deg)</label><input id="pitch" type="range" min="5" max="40" step="0.5" value="18"></div>
  <div class="row"><label>–û—Ç–¥–∞–ª—ë–Ω–Ω–æ—Å—Ç—å (fov)</label><input id="fov" type="range" min="200" max="1800" step="10" value="900"></div>
  <div class="row"><label>–°–µ–≥–º–µ–Ω—Ç—ã (–≥–æ—Ä–∏–∑.)</label><input id="segments" type="range" min="24" max="400" step="1" value="200"></div>
  <div class="row"><label>–ì–ª—É–±–∏–Ω–∞ (—Ä—è–¥–æ–≤)</label><input id="depth" type="range" min="12" max="300" step="1" value="150"></div>
  <div class="row"><label>–®–∏—Ä–∏–Ω–∞ –ª–∏–Ω–∏–π</label><input id="lineWidth" type="range" min="0.2" max="3.5" step="0.1" value="1"></div>
  <div class="row"><label>–¶–≤–µ—Ç –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞</label><input id="color" type="color" value="#33ffdd"></div>
  <div class="row checkbox"><input id="showGrid" type="checkbox"><label for="showGrid">–ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É (grid)</label></div>
  <div class="row checkbox"><input id="shipWobble" type="checkbox" checked><label for="shipWobble">–ö–æ—Ä–∞–±–ª—å –∫–∞—á–∞–µ—Ç—Å—è</label></div>
  <div class="row checkbox"><input id="shipFill" type="checkbox"><label for="shipFill">–ó–∞–ª–∏–≤–∫–∞ –∫–æ—Ä–∞–±–ª—è</label></div>
  <div class="row checkbox"><input id="gradientColor" type="checkbox" checked><label for="gradientColor">–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–π —Ü–≤–µ—Ç</label></div>
  <div class="row checkbox"><input id="gameMode" type="checkbox"><label for="gameMode">–ò–≥—Ä–æ–≤–æ–π —Ä–µ–∂–∏–º</label></div>

  <div class="controls">
    <button id="hideUI">–°–∫—Ä—ã—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</button>
    <button id="pause">–ü–∞—É–∑–∞</button>
    <button id="reset">–°–±—Ä–æ—Å</button>
  </div>
  <div class="small">–í –∏–≥—Ä–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç—Ä–µ–ª–∫–∏ ‚Üê ‚Üí –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è. –ò–∑–±–µ–≥–∞–π—Ç–µ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å —Ä–µ–ª—å–µ—Ñ–æ–º!</div>
</div>

<div class="ui-toggle hidden" id="uiToggle">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"/>
  </svg>
</div>

<div class="game-info" id="gameInfo">
  <div>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: ‚Üê ‚Üí</div>
  <div>–°–∫–æ—Ä–æ—Å—Ç—å: <span id="gameSpeed">0</span></div>
  <div>–î–∏—Å—Ç–∞–Ω—Ü–∏—è: <span id="gameDistance">0</span></div>
  <div>–°—Ç–∞—Ç—É—Å: <span id="gameStatus">‚úÖ –í –ø–æ–ª—ë—Ç–µ</span></div>
</div>

<script>
// ----------------------------- Helpers: noise (2D value noise) -----------------------------
function hash(ix, iy){
  // 32-bit integer hash
  let h = ix*374761393 + iy*668265263; h = (h ^ (h >> 13)) * 1274126177; h = (h ^ (h >> 16));
  return (h >>> 0) / 4294967295;
}
function smoothstep(t){ return t * t * (3 - 2 * t); }
function valueNoise2D(x, y){
  const xi = Math.floor(x), yi = Math.floor(y);
  const xf = x - xi, yf = y - yi;
  const a = hash(xi, yi);
  const b = hash(xi+1, yi);
  const c = hash(xi, yi+1);
  const d = hash(xi+1, yi+1);
  const u = smoothstep(xf);
  const v = smoothstep(yf);
  const lerp = (A,B,t)=> A + (B-A)*t;
  const ab = lerp(a,b,u);
  const cd = lerp(c,d,u);
  return lerp(ab, cd, v);
}

// Fractal noise (fbm) —Å –±–æ–ª–µ–µ —Ä–µ–∑–∫–∏–º–∏ –ø–∏–∫–∞–º–∏
function fbm(x,y,octaves, lacunarity, gain){
  let sum=0, amp=1, freq=1, max=0;
  for(let i=0;i<octaves;i++){
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –æ—Å—Ç—Ä—ã—Ö –ø–∏–∫–æ–≤
    let noiseVal = valueNoise2D(x*freq, y*freq);
    noiseVal = Math.pow(noiseVal, 1.5); // –î–µ–ª–∞–µ–º –ø–∏–∫–∏ –±–æ–ª–µ–µ –æ—Å—Ç—Ä—ã–º–∏
    sum += noiseVal * amp;
    max += amp; amp *= gain; freq *= lacunarity;
  }
  return sum / max;
}

// ----------------------------- Canvas & state -----------------------------
const canvas = document.getElementById('cnv');
const ctx = canvas.getContext('2d');
let W = 0, H = 0;
function resize(){
  const dpr = window.devicePixelRatio || 1;
  W = canvas.width = Math.floor(innerWidth * dpr);
  H = canvas.height = Math.floor(innerHeight * dpr);
  canvas.style.width = innerWidth + 'px';
  canvas.style.height = innerHeight + 'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize', resize);
resize();

// Settings
const UI = {
  shipType: '1',
  shipColor: '#33ffdd',
  shipAccentColor: '#aaffff',
  speed:1,
  amplitude:120,
  freq:1.5,
  pitch:18, // degrees
  fov:900,
  segments:200,
  depth:150,
  lineWidth:1,
  color:'#33ffdd',
  showGrid:false,
  shipWobble:true,
  shipFill:false,
  gradientColor:true,
  gameMode: false
};

// Game state
const Game = {
  shipX: 0,
  distance: 0,
  crashed: false,
  keys: {
    left: false,
    right: false
  }
};

// bind UI controls
function $(id){ return document.getElementById(id); }
['speed','amplitude','freq','pitch','fov','segments','depth','lineWidth','color','shipType','shipColor','shipAccentColor'].forEach(id=>{
  const el = $(id);
  el.addEventListener('input', ()=>{
    const v = el.type === 'range' ? parseFloat(el.value) : el.value;
    UI[id] = v;
    if(id==='segments' || id==='depth') rebuildGrid();
  });
});
$('showGrid').addEventListener('change', e=> UI.showGrid = e.target.checked);
$('shipWobble').addEventListener('change', e=> UI.shipWobble = e.target.checked);
$('shipFill').addEventListener('change', e=> UI.shipFill = e.target.checked);
$('gradientColor').addEventListener('change', e=> UI.gradientColor = e.target.checked);
$('gameMode').addEventListener('change', e=> {
  UI.gameMode = e.target.checked;
  $('gameInfo').classList.toggle('active', UI.gameMode);
  if (UI.gameMode) {
    Game.shipX = 0;
    Game.distance = 0;
    Game.crashed = false;
  }
});

let paused=false; $('pause').addEventListener('click', ()=>{ paused = !paused; $('pause').textContent = paused ? '–í–æ–∑–æ–±–Ω–æ–≤–∏—Ç—å' : '–ü–∞—É–∑–∞'; });
$('reset').addEventListener('click', ()=>{ rebuildGrid(true); });
$('hideUI').addEventListener('click', ()=>{ 
  $('ui').classList.add('hidden');
  $('uiToggle').classList.remove('hidden');
});

$('uiToggle').addEventListener('click', ()=>{ 
  $('ui').classList.remove('hidden');
  $('uiToggle').classList.add('hidden');
});

// Keyboard controls for game mode
document.addEventListener('keydown', (e) => {
  if (!UI.gameMode || paused) return;
  
  if (e.key === 'ArrowLeft') Game.keys.left = true;
  if (e.key === 'ArrowRight') Game.keys.right = true;
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft') Game.keys.left = false;
  if (e.key === 'ArrowRight') Game.keys.right = false;
});

// Terrain grid parameters
let segments = Math.max(24, Math.floor(UI.segments));
let depthSteps = Math.max(12, Math.floor(UI.depth));
let grid = []; // grid[depthIndex][segIndex] = {x,y,z}
let timeOffset = 0;

function rebuildGrid(forceRandom=false){
  segments = Math.max(24, Math.floor(UI.segments));
  depthSteps = Math.max(12, Math.floor(UI.depth));
  grid = [];
  for(let d=0; d<depthSteps; d++){
    const row = [];
    for(let s=0; s<=segments; s++){
      row.push({x:0,y:0,z:0});
    }
    grid.push(row);
  }
}
rebuildGrid();

// projection: transform point (x_world, y_world, z_world) to screen
function projectPoint(px, py, pz, camera){
  // camera: {x,y,z, pitchRad, fov}
  // translate to camera space (camera at origin looking along +z)
  const x = px - camera.x;
  const y = py - camera.y;
  const z = pz - camera.z;
  // rotate around x (pitch)
  const sinp = Math.sin(camera.pitch), cosp = Math.cos(camera.pitch);
  const z2 = z * cosp - y * sinp;
  const y2 = z * sinp + y * cosp;
  // only draw points in front of camera
  if(z2 <= 1) return null;
  const scale = camera.fov / z2;
  const sx = camera.cx + x * scale;
  const sy = camera.cy - y2 * scale;
  return {sx, sy, scale};
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≥–ª—É–±–∏–Ω—ã
function getGradientColor(baseColor, depthRatio) {
  if (!UI.gradientColor) return baseColor;
  
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º hex –≤ RGB
  const r = parseInt(baseColor.slice(1, 3), 16);
  const g = parseInt(baseColor.slice(3, 5), 16);
  const b = parseInt(baseColor.slice(5, 7), 16);
  
  // –°–æ–∑–¥–∞–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ –∫ —Å–∏–Ω–µ–º—É –¥–ª—è –¥–∞–ª–µ–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤
  const targetR = 50;
  const targetG = 100;
  const targetB = 200;
  
  const mix = Math.pow(depthRatio, 0.7); // –ë–æ–ª–µ–µ –ø–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥
  
  const resultR = Math.floor(r * (1 - mix) + targetR * mix);
  const resultG = Math.floor(g * (1 - mix) + targetG * mix);
  const resultB = Math.floor(b * (1 - mix) + targetB * mix);
  
  return `rgb(${resultR}, ${resultG}, ${resultB})`;
}

// –†–∏—Å–æ–≤–∞–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è —Ç–∏–ø–∞ 1 - –ò—Å—Ç—Ä–µ–±–∏—Ç–µ–ª—å (—É–ª—å—Ç—Ä–∞ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
function drawShipFighter(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  // –í –∏–≥—Ä–æ–≤–æ–º —Ä–µ–∂–∏–º–µ —É—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–æ—Ä–∞–±–ª—è
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180);
  
  const scale = 1.2;
  const enginePulse = Math.abs(Math.sin(t * 0.01)) * 0.5 + 0.5;
  
  // –û—Å–Ω–æ–≤–Ω—ã–µ —Ü–≤–µ—Ç–∞
  const mainColor = primaryColor;
  const engineColor = `rgba(255, 100, 50, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // –ú–µ–Ω—å—à–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ (93%)
  
  // –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ –∑–∞–ª–∏–≤–∫–∞, —Å–Ω–∞—á–∞–ª–∞ –∑–∞–ª–∏–≤–∞–µ–º
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç—É—Ä –∫–æ—Ä–ø—É—Å–∞ –¥–ª—è –∑–∞–ª–∏–≤–∫–∏
    ctx.moveTo(0, -22 * scale);
    ctx.bezierCurveTo(-8 * scale, -20 * scale, -15 * scale, -15 * scale, -25 * scale, -5 * scale);
    ctx.bezierCurveTo(-30 * scale, 2 * scale, -28 * scale, 12 * scale, -22 * scale, 18 * scale);
    ctx.lineTo(-15 * scale, 22 * scale);
    ctx.lineTo(15 * scale, 22 * scale);
    ctx.lineTo(22 * scale, 18 * scale);
    ctx.bezierCurveTo(28 * scale, 12 * scale, 30 * scale, 2 * scale, 25 * scale, -5 * scale);
    ctx.bezierCurveTo(15 * scale, -15 * scale, 8 * scale, -20 * scale, 0, -22 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // –ö–æ–Ω—Ç—É—Ä –∏—Å—Ç—Ä–µ–±–∏—Ç–µ–ª—è
  ctx.moveTo(0, -22 * scale);
  ctx.bezierCurveTo(-8 * scale, -20 * scale, -15 * scale, -15 * scale, -25 * scale, -5 * scale);
  ctx.bezierCurveTo(-30 * scale, 2 * scale, -28 * scale, 12 * scale, -22 * scale, 18 * scale);
  ctx.lineTo(-15 * scale, 22 * scale);
  ctx.lineTo(15 * scale, 22 * scale);
  ctx.lineTo(22 * scale, 18 * scale);
  ctx.bezierCurveTo(28 * scale, 12 * scale, 30 * scale, 2 * scale, 25 * scale, -5 * scale);
  ctx.bezierCurveTo(15 * scale, -15 * scale, 8 * scale, -20 * scale, 0, -22 * scale);
  
  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
  ctx.moveTo(0, -22 * scale);
  ctx.lineTo(0, 22 * scale);
  
  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Ä–µ–±—Ä–∞ –∂–µ—Å—Ç–∫–æ—Å—Ç–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -20; i <= 20; i += 1.5) {
    const y = i * scale;
    const curveFactor = Math.sin(i * 0.15) * 3;
    const width = (15 + Math.abs(i) * 0.7 + curveFactor) * scale;
    if (i === 0) continue;
    ctx.moveTo(-width, y);
    ctx.lineTo(width, y);
  }
  
  // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ —Ä–µ–±—Ä–∞ –∂–µ—Å—Ç–∫–æ—Å—Ç–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -28; i <= 28; i += 2) {
    const x = i * scale;
    if (Math.abs(x) > 30 * scale) continue;
    const curveFactor = Math.cos(x * 0.05) * 4;
    const height = (22 - Math.abs(i) * 0.5 + curveFactor) * scale;
    if (x === 0) continue;
    ctx.moveTo(x, -height);
    ctx.lineTo(x, height);
  }
  
  // –î–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–±—Ä–∞ –∂–µ—Å—Ç–∫–æ—Å—Ç–∏ –¥–ª—è –æ–±—ä–µ–º–∞ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -20; i <= 20; i += 3) {
    const y = i * scale;
    // –õ–µ–≤–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å
    ctx.moveTo(-25 * scale, -5 * scale);
    ctx.lineTo(0, y);
    // –ü—Ä–∞–≤–∞—è –¥–∏–∞–≥–æ–Ω–∞–ª—å
    ctx.moveTo(25 * scale, -5 * scale);
    ctx.lineTo(0, y);
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∏–∞–≥–æ–Ω–∞–ª–∏
    ctx.moveTo(-20 * scale, 10 * scale);
    ctx.lineTo(10 * scale, -15 * scale);
    ctx.moveTo(20 * scale, 10 * scale);
    ctx.lineTo(-10 * scale, -15 * scale);
  }
  
  // –û—Å–Ω–æ–≤–Ω—ã–µ –∫—Ä—ã–ª—å—è —Å –∫—Ä–∏–≤—ã–º–∏
  ctx.moveTo(-18 * scale, 5 * scale);
  ctx.bezierCurveTo(-28 * scale, 2 * scale, -38 * scale, 0 * scale, -45 * scale, -2 * scale);
  ctx.bezierCurveTo(-44 * scale, 5 * scale, -40 * scale, 10 * scale, -42 * scale, 12 * scale);
  ctx.bezierCurveTo(-35 * scale, 12 * scale, -25 * scale, 10 * scale, -18 * scale, 12 * scale);
  ctx.closePath();
  
  ctx.moveTo(18 * scale, 5 * scale);
  ctx.bezierCurveTo(28 * scale, 2 * scale, 38 * scale, 0 * scale, 45 * scale, -2 * scale);
  ctx.bezierCurveTo(44 * scale, 5 * scale, 40 * scale, 10 * scale, 42 * scale, 12 * scale);
  ctx.bezierCurveTo(35 * scale, 12 * scale, 25 * scale, 10 * scale, 18 * scale, 12 * scale);
  ctx.closePath();
  
  // –°—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –Ω–∞ –∫—Ä—ã–ª—å—è—Ö (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = 0; i <= 1; i += 0.08) {
    const x1 = -18 + (-27) * i;
    const y1 = 5 + (-7) * i;
    const x2 = -18 + (-24) * i;
    const y2 = 5 + 7 * i;
    ctx.moveTo(x1 * scale, y1 * scale);
    ctx.lineTo(x2 * scale, y2 * scale);
    
    const x3 = 18 + 27 * i;
    const y3 = 5 + (-7) * i;
    const x4 = 18 + 24 * i;
    const y4 = 5 + 7 * i;
    ctx.moveTo(x3 * scale, y3 * scale);
    ctx.lineTo(x4 * scale, y4 * scale);
  }
  
  // –•–≤–æ—Å—Ç–æ–≤–æ–µ –æ–ø–µ—Ä–µ–Ω–∏–µ —Å –∫—Ä–∏–≤—ã–º–∏
  ctx.moveTo(-8 * scale, 22 * scale);
  ctx.bezierCurveTo(-10 * scale, 26 * scale, -13 * scale, 30 * scale, -15 * scale, 32 * scale);
  ctx.lineTo(-5 * scale, 28 * scale);
  ctx.bezierCurveTo(-3 * scale, 26 * scale, -2 * scale, 24 * scale, 0, 22 * scale);
  ctx.moveTo(8 * scale, 22 * scale);
  ctx.bezierCurveTo(10 * scale, 26 * scale, 13 * scale, 30 * scale, 15 * scale, 32 * scale);
  ctx.lineTo(5 * scale, 28 * scale);
  ctx.bezierCurveTo(3 * scale, 26 * scale, 2 * scale, 24 * scale, 0, 22 * scale);
  
  // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ç–æ—Ä
  ctx.moveTo(0, 22 * scale);
  ctx.bezierCurveTo(1 * scale, 28 * scale, 0.5 * scale, 32 * scale, 0, 35 * scale);
  ctx.bezierCurveTo(-3 * scale, 33 * scale, -5 * scale, 31 * scale, -6 * scale, 32 * scale);
  ctx.bezierCurveTo(-4 * scale, 30 * scale, -2 * scale, 28 * scale, 0, 26 * scale);
  ctx.bezierCurveTo(2 * scale, 28 * scale, 4 * scale, 30 * scale, 6 * scale, 32 * scale);
  ctx.bezierCurveTo(5 * scale, 31 * scale, 3 * scale, 33 * scale, 0, 35 * scale);
  
  // –°—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –Ω–∞ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ç–æ—Ä–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = 0; i <= 1; i += 0.1) {
    const y = 22 + 13 * i;
    const width = 6 * (1 - i * 0.8);
    ctx.moveTo(-width * scale, y * scale);
    ctx.lineTo(width * scale, y * scale);
  }
  
  // –ö–∞–±–∏–Ω–∞ –ø–∏–ª–æ—Ç–∞ - –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å –∫—Ä–∏–≤—ã–º–∏
  ctx.moveTo(-8 * scale, -15 * scale);
  ctx.bezierCurveTo(-9 * scale, -12 * scale, -10 * scale, -9 * scale, -10 * scale, -8 * scale);
  ctx.bezierCurveTo(-5 * scale, -6 * scale, 5 * scale, -6 * scale, 10 * scale, -8 * scale);
  ctx.bezierCurveTo(10 * scale, -9 * scale, 9 * scale, -12 * scale, 8 * scale, -15 * scale);
  ctx.closePath();
  
  // –ü–µ—Ä–µ–≥–æ—Ä–æ–¥–∫–∏ –≤ –∫–∞–±–∏–Ω–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -7; i <= 7; i += 1.2) {
    ctx.moveTo(i * scale, -15 * scale);
    ctx.lineTo(i * scale, -8 * scale);
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –≤ –∫–∞–±–∏–Ω–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -13; i <= -7; i += 0.8) {
    const y = i * scale;
    const width = 8 - Math.abs(i + 10) * 0.3;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // –î–≤–∏–≥–∞—Ç–µ–ª–∏ - –±–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω—ã–µ
  ctx.moveTo(-20 * scale, 18 * scale);
  ctx.bezierCurveTo(-22 * scale, 21 * scale, -24 * scale, 23 * scale, -25 * scale, 25 * scale);
  ctx.lineTo(-15 * scale, 25 * scale);
  ctx.bezierCurveTo(-16 * scale, 23 * scale, -18 * scale, 21 * scale, -20 * scale, 18 * scale);
  
  ctx.moveTo(20 * scale, 18 * scale);
  ctx.bezierCurveTo(22 * scale, 21 * scale, 24 * scale, 23 * scale, 25 * scale, 25 * scale);
  ctx.lineTo(15 * scale, 25 * scale);
  ctx.bezierCurveTo(16 * scale, 23 * scale, 18 * scale, 21 * scale, 20 * scale, 18 * scale);
  
  // –°—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –Ω–∞ –¥–≤–∏–≥–∞—Ç–µ–ª—è—Ö (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = 0; i <= 1; i += 0.15) {
    const y = 18 + 7 * i;
    const width = 5 * (1 - i * 0.5);
    ctx.moveTo((-20 - width) * scale, y * scale);
    ctx.lineTo((-20 + width) * scale, y * scale);
    
    ctx.moveTo((20 - width) * scale, y * scale);
    ctx.lineTo((20 + width) * scale, y * scale);
  }
  
  // –°–æ–ø–ª–∞ –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π
  ctx.moveTo(-20 * scale, 25 * scale);
  ctx.bezierCurveTo(-21 * scale, 26 * scale, -22 * scale, 27 * scale, -22 * scale, 28 * scale);
  ctx.lineTo(-18 * scale, 28 * scale);
  ctx.bezierCurveTo(-19 * scale, 27 * scale, -20 * scale, 26 * scale, -20 * scale, 25 * scale);
  
  ctx.moveTo(20 * scale, 25 * scale);
  ctx.bezierCurveTo(21 * scale, 26 * scale, 22 * scale, 27 * scale, 22 * scale, 28 * scale);
  ctx.lineTo(18 * scale, 28 * scale);
  ctx.bezierCurveTo(19 * scale, 27 * scale, 20 * scale, 26 * scale, 20 * scale, 25 * scale);
  
  // –û—Ä—É–¥–∏—è –Ω–∞ –∫—Ä—ã–ª—å—è—Ö
  ctx.moveTo(-40 * scale, 0 * scale);
  ctx.bezierCurveTo(-42 * scale, -2 * scale, -43 * scale, -3 * scale, -44 * scale, -4 * scale);
  ctx.lineTo(-44 * scale, 4 * scale);
  ctx.bezierCurveTo(-43 * scale, 3 * scale, -42 * scale, 2 * scale, -40 * scale, 0 * scale);
  
  ctx.moveTo(40 * scale, 0 * scale);
  ctx.bezierCurveTo(42 * scale, -2 * scale, 43 * scale, -3 * scale, 44 * scale, -4 * scale);
  ctx.lineTo(44 * scale, 4 * scale);
  ctx.bezierCurveTo(43 * scale, 3 * scale, 42 * scale, 2 * scale, 40 * scale, 0 * scale);
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
  // –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø–æ—Ä—Ç—ã –∏ –≤–µ–Ω—Ç–∏–ª—è—Ü–∏–æ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ä—Å—Ç–∏—è
  for (let i = -15; i <= 15; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    const size = 2 * scale;
    ctx.moveTo(x - size, 5 * scale);
    ctx.lineTo(x + size, 5 * scale);
    ctx.moveTo(x, 5 * scale - size);
    ctx.lineTo(x, 5 * scale + size);
  }
  
  // –ü–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏ —Å–µ–Ω—Å–æ—Ä—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -12; i <= 12; i += 3) {
    const x = i * scale;
    // –ü–∞–Ω–µ–ª–∏ –Ω–∞ –∫–æ—Ä–ø—É—Å–µ
    ctx.moveTo(x - 1.5 * scale, -8 * scale);
    ctx.lineTo(x + 1.5 * scale, -8 * scale);
    ctx.moveTo(x - 1.5 * scale, -10 * scale);
    ctx.lineTo(x + 1.5 * scale, -10 * scale);
    
    // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x, 11 * scale);
    ctx.lineTo(x, 13 * scale);
  }
  
  // –°–∏—Å—Ç–µ–º—ã –æ—Ö–ª–∞–∂–¥–µ–Ω–∏—è (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -22; i <= 22; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, 15 * scale);
    ctx.lineTo(x + 2 * scale, 15 * scale);
    ctx.moveTo(x - 2 * scale, 17 * scale);
    ctx.lineTo(x + 2 * scale, 17 * scale);
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ—Ä—É–¥–∏—è –∏ —Å–∏—Å—Ç–µ–º—ã –≤–æ–æ—Ä—É–∂–µ–Ω–∏—è
  for (let i = -35; i <= 35; i += 20) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, -2 * scale);
    ctx.lineTo(x + 1.5 * scale, -2 * scale);
    ctx.moveTo(x - 1.5 * scale, 2 * scale);
    ctx.lineTo(x + 1.5 * scale, 2 * scale);
    ctx.moveTo(x, -2 * scale);
    ctx.lineTo(x, 2 * scale);
  }
  
  ctx.stroke();
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ —Å –¥—Ä—É–≥–∏–º —Ü–≤–µ—Ç–æ–º/—Ç–æ–ª—â–∏–Ω–æ–π
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.7;
  
  ctx.beginPath();
  // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ –Ω–∞ –∫–æ—Ä–ø—É—Å–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -25; i <= 25; i += 1.5) {
    if (i === 0) continue;
    const x = i * scale;
    const height = 20 - Math.abs(i) * 0.4;
    ctx.moveTo(x, -height * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // –ö–æ–ª—å—Ü–∞ –Ω–∞ –Ω–æ—Å–æ–≤–æ–π —á–∞—Å—Ç–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = 1; i <= 12; i++) {
    const radius = i * 1.5 * scale;
    ctx.moveTo(-radius, -20 * scale + i * 1.0);
    ctx.lineTo(radius, -20 * scale + i * 1.0);
  }
  
  // –°–ª–æ–∂–Ω—ã–µ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ª–∏–Ω–∏–∏ —Å –∫—Ä–∏–≤—ã–º–∏
  for (let i = -20; i <= 20; i += 4) {
    const x = i * scale;
    const curveHeight = 8 * Math.sin(i * 0.15);
    ctx.moveTo(x, -15 * scale);
    ctx.bezierCurveTo(
      x, -10 * scale + curveHeight,
      x, -5 * scale - curveHeight,
      x, 5 * scale
    );
  }
  
  // –°—Ö–µ–º—ã –ø—Ä–æ–≤–æ–¥–∫–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -18; i <= 18; i += 4) {
    const x = i * scale;
    ctx.moveTo(x, -5 * scale);
    ctx.bezierCurveTo(
      x - 2 * scale, 0,
      x + 2 * scale, 5 * scale,
      x, 10 * scale
    );
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–µ–Ω—Å–æ—Ä–Ω—ã–µ —Ä–µ—à–µ—Ç–∫–∏
  for (let i = -10; i <= 10; i += 5) {
    const x = i * scale;
    for (let j = -12; j <= -8; j += 1) {
      const y = j * scale;
      ctx.moveTo(x - 1 * scale, y);
      ctx.lineTo(x + 1 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // –°–≤–µ—á–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.5;
  
  ctx.beginPath();
  // –ò–º–ø—É–ª—å—Å—ã –æ—Ç –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π
  for (let i = 1; i <= 12; i++) {
    const length = 4 + i * 1.2;
    const spread = i * 0.4;
    ctx.moveTo(-20 * scale - spread, 28 * scale);
    ctx.lineTo(-20 * scale - spread, 28 * scale + length);
    ctx.moveTo(-20 * scale + spread, 28 * scale);
    ctx.lineTo(-20 * scale + spread, 28 * scale + length);
    
    ctx.moveTo(20 * scale - spread, 28 * scale);
    ctx.lineTo(20 * scale - spread, 28 * scale + length);
    ctx.moveTo(20 * scale + spread, 28 * scale);
    ctx.lineTo(20 * scale + spread, 28 * scale + length);
  }
  
  ctx.stroke();
  
  ctx.restore();
}

// –†–∏—Å–æ–≤–∞–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è —Ç–∏–ø–∞ 2 - –ö—Ä–µ–π—Å–µ—Ä (—É–ª—å—Ç—Ä–∞ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
function drawShipCruiser(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180 * 0.7); // –ú–µ–Ω—å—à–µ –∫–∞—á–∞–Ω–∏–µ –¥–ª—è –±–æ–ª—å—à–æ–≥–æ –∫–æ—Ä–∞–±–ª—è
  
  const scale = 1.5; // –ë–æ–ª—å—à–µ —Ä–∞–∑–º–µ—Ä
  const enginePulse = Math.abs(Math.sin(t * 0.008)) * 0.5 + 0.5;
  
  const mainColor = primaryColor;
  const engineColor = `rgba(255, 150, 50, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // –ú–µ–Ω—å—à–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ (93%)
  
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // –ú–∞—Å—Å–∏–≤–Ω—ã–π –∫–æ—Ä–ø—É—Å –∫—Ä–µ–π—Å–µ—Ä–∞
    ctx.moveTo(0, -18 * scale);
    ctx.bezierCurveTo(-12 * scale, -16 * scale, -25 * scale, -12 * scale, -35 * scale, -12 * scale);
    ctx.bezierCurveTo(-38 * scale, -8 * scale, -40 * scale, 0 * scale, -40 * scale, 5 * scale);
    ctx.bezierCurveTo(-38 * scale, 15 * scale, -32 * scale, 22 * scale, -30 * scale, 25 * scale);
    ctx.lineTo(-15 * scale, 30 * scale);
    ctx.lineTo(15 * scale, 30 * scale);
    ctx.lineTo(30 * scale, 25 * scale);
    ctx.bezierCurveTo(32 * scale, 22 * scale, 38 * scale, 15 * scale, 40 * scale, 5 * scale);
    ctx.bezierCurveTo(40 * scale, 0 * scale, 38 * scale, -8 * scale, 35 * scale, -12 * scale);
    ctx.bezierCurveTo(25 * scale, -12 * scale, 12 * scale, -16 * scale, 0, -18 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
  ctx.moveTo(0, -18 * scale);
  ctx.bezierCurveTo(-12 * scale, -16 * scale, -25 * scale, -12 * scale, -35 * scale, -12 * scale);
  ctx.bezierCurveTo(-38 * scale, -8 * scale, -40 * scale, 0 * scale, -40 * scale, 5 * scale);
  ctx.bezierCurveTo(-38 * scale, 15 * scale, -32 * scale, 22 * scale, -30 * scale, 25 * scale);
  ctx.lineTo(-15 * scale, 30 * scale);
  ctx.lineTo(15 * scale, 30 * scale);
  ctx.lineTo(30 * scale, 25 * scale);
  ctx.bezierCurveTo(32 * scale, 22 * scale, 38 * scale, 15 * scale, 40 * scale, 5 * scale);
  ctx.bezierCurveTo(40 * scale, 0 * scale, 38 * scale, -8 * scale, 35 * scale, -12 * scale);
  ctx.bezierCurveTo(25 * scale, -12 * scale, 12 * scale, -16 * scale, 0, -18 * scale);
  
  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
  ctx.moveTo(0, -18 * scale);
  ctx.lineTo(0, 30 * scale);
  
  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -15; i <= 30; i += 1.5) {
    const y = i * scale;
    if (y > 30 * scale) continue;
    const width = 35 - Math.abs(i + 5) * 0.5;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // –ú–æ—Å—Ç–∏–∫
  ctx.moveTo(-12 * scale, -10 * scale);
  ctx.lineTo(12 * scale, -10 * scale);
  ctx.lineTo(15 * scale, -5 * scale);
  ctx.lineTo(-15 * scale, -5 * scale);
  ctx.closePath();
  
  // –ë–æ–ª—å—à–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª–∏
  ctx.moveTo(-20 * scale, 30 * scale);
  ctx.bezierCurveTo(-22 * scale, 33 * scale, -24 * scale, 36 * scale, -25 * scale, 40 * scale);
  ctx.lineTo(-15 * scale, 40 * scale);
  ctx.bezierCurveTo(-16 * scale, 36 * scale, -18 * scale, 33 * scale, -20 * scale, 30 * scale);
  
  ctx.moveTo(20 * scale, 30 * scale);
  ctx.bezierCurveTo(22 * scale, 33 * scale, 24 * scale, 36 * scale, 25 * scale, 40 * scale);
  ctx.lineTo(15 * scale, 40 * scale);
  ctx.bezierCurveTo(16 * scale, 36 * scale, 18 * scale, 33 * scale, 20 * scale, 30 * scale);
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–≤–∏–≥–∞—Ç–µ–ª–∏
  ctx.moveTo(-8 * scale, 30 * scale);
  ctx.bezierCurveTo(-10 * scale, 33 * scale, -11 * scale, 35 * scale, -12 * scale, 38 * scale);
  ctx.lineTo(-4 * scale, 38 * scale);
  ctx.bezierCurveTo(-5 * scale, 35 * scale, -6 * scale, 33 * scale, -8 * scale, 30 * scale);
  
  ctx.moveTo(8 * scale, 30 * scale);
  ctx.bezierCurveTo(10 * scale, 33 * scale, 11 * scale, 35 * scale, 12 * scale, 38 * scale);
  ctx.lineTo(4 * scale, 38 * scale);
  ctx.bezierCurveTo(5 * scale, 35 * scale, 6 * scale, 33 * scale, 8 * scale, 30 * scale);
  
  // –ê–Ω—Ç–µ–Ω–Ω—ã –∏ —Å–µ–Ω—Å–æ—Ä—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  ctx.moveTo(-5 * scale, -18 * scale);
  ctx.lineTo(-8 * scale, -25 * scale);
  ctx.moveTo(5 * scale, -18 * scale);
  ctx.lineTo(8 * scale, -25 * scale);
  ctx.moveTo(0, -18 * scale);
  ctx.lineTo(0, -22 * scale);
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞–Ω—Ç–µ–Ω–Ω—ã
  for (let i = -10; i <= 10; i += 5) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x, -18 * scale);
    ctx.lineTo(x, -21 * scale);
  }
  
  // –û—Ä—É–¥–∏–π–Ω—ã–µ –±–∞—à–Ω–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -25; i <= 25; i += 8) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x - 3 * scale, 8 * scale);
    ctx.lineTo(x + 3 * scale, 8 * scale);
    ctx.moveTo(x - 3 * scale, 12 * scale);
    ctx.lineTo(x + 3 * scale, 12 * scale);
    ctx.moveTo(x, 8 * scale);
    ctx.lineTo(x, 12 * scale);
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ—Ä—É–¥–∏—è
    ctx.moveTo(x - 2 * scale, 5 * scale);
    ctx.lineTo(x + 2 * scale, 5 * scale);
    ctx.moveTo(x - 2 * scale, 15 * scale);
    ctx.lineTo(x + 2 * scale, 15 * scale);
  }
  
  // –®–ª—é–∑–æ–≤—ã–µ –æ—Ç—Å–µ–∫–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -20; i <= 20; i += 10) {
    const x = i * scale;
    ctx.moveTo(x - 4 * scale, 18 * scale);
    ctx.lineTo(x + 4 * scale, 18 * scale);
    ctx.moveTo(x - 4 * scale, 22 * scale);
    ctx.lineTo(x + 4 * scale, 22 * scale);
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —à–ª—é–∑—ã
    ctx.moveTo(x - 3 * scale, 20 * scale);
    ctx.lineTo(x + 3 * scale, 20 * scale);
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
  for (let i = -30; i <= 30; i += 15) {
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, -5 * scale);
    ctx.lineTo(x + 2 * scale, -5 * scale);
    ctx.moveTo(x - 2 * scale, 25 * scale);
    ctx.lineTo(x + 2 * scale, 25 * scale);
  }
  
  ctx.stroke();
  
  // –î–µ—Ç–∞–ª–∏ —Å –∞–∫—Ü–µ–Ω—Ç–Ω—ã–º —Ü–≤–µ—Ç–æ–º
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.7;
  
  ctx.beginPath();
  
  // –ü–∞–Ω–µ–ª–∏ –Ω–∞ –∫–æ—Ä–ø—É—Å–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -30; i <= 30; i += 2) {
    if (i === 0) continue;
    const x = i * scale;
    const height = 25 - Math.abs(i) * 0.3;
    ctx.moveTo(x, -15 * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // –û–∫–Ω–∞ –Ω–∞ –º–æ—Å—Ç–∏–∫–µ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -10; i <= 10; i += 1.5) {
    ctx.moveTo(i * scale, -8 * scale);
    ctx.lineTo(i * scale, -6 * scale);
  }
  
  // –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø–∞–Ω–µ–ª–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -28; i <= 28; i += 7) {
    const x = i * scale;
    for (let j = 5; j <= 20; j += 3) {
      const y = j * scale;
      ctx.moveTo(x - 2 * scale, y);
      ctx.lineTo(x + 2 * scale, y);
    }
  }
  
  // –°–∏—Å—Ç–µ–º—ã –≤–µ–Ω—Ç–∏–ª—è—Ü–∏–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -32; i <= 32; i += 8) {
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, 2 * scale);
    ctx.lineTo(x + 1.5 * scale, 2 * scale);
    ctx.moveTo(x - 1.5 * scale, 4 * scale);
    ctx.lineTo(x + 1.5 * scale, 4 * scale);
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–µ–Ω—Å–æ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã
  for (let i = -15; i <= 15; i += 10) {
    const x = i * scale;
    for (let j = -12; j <= -8; j += 1) {
      const y = j * scale;
      ctx.moveTo(x - 1 * scale, y);
      ctx.lineTo(x + 1 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // –î–≤–∏–≥–∞—Ç–µ–ª–∏
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.5;
  
  ctx.beginPath();
  
  for (let i = 1; i <= 8; i++) {
    const length = 8 + i * 1.5;
    const spread = i * 0.7;
    // –û—Å–Ω–æ–≤–Ω—ã–µ –¥–≤–∏–≥–∞—Ç–µ–ª–∏
    ctx.moveTo(-22 * scale - spread, 40 * scale);
    ctx.lineTo(-22 * scale - spread, 40 * scale + length);
    ctx.moveTo(-22 * scale + spread, 40 * scale);
    ctx.lineTo(-22 * scale + spread, 40 * scale + length);
    
    ctx.moveTo(22 * scale - spread, 40 * scale);
    ctx.lineTo(22 * scale - spread, 40 * scale + length);
    ctx.moveTo(22 * scale + spread, 40 * scale);
    ctx.lineTo(22 * scale + spread, 40 * scale + length);
    
    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –¥–≤–∏–≥–∞—Ç–µ–ª–∏
    ctx.moveTo(-10 * scale, 38 * scale);
    ctx.lineTo(-10 * scale, 38 * scale + length * 0.7);
    ctx.moveTo(10 * scale, 38 * scale);
    ctx.lineTo(10 * scale, 38 * scale + length * 0.7);
  }
  
  ctx.stroke();
  ctx.restore();
}

// –†–∏—Å–æ–≤–∞–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è —Ç–∏–ø–∞ 3 - –†–∞–∑–≤–µ–¥—á–∏–∫ (—É–ª—å—Ç—Ä–∞ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
function drawShipScout(ctx, t, shipBaseX, shipBaseY, wobble, bob, lineWidth, primaryColor, accentColor, fillShip) {
  ctx.save();
  
  const finalX = UI.gameMode ? shipBaseX + Game.shipX : shipBaseX;
  ctx.translate(finalX, shipBaseY + bob);
  ctx.rotate(wobble * Math.PI/180 * 1.3); // –ë–æ–ª—å—à–µ –∫–∞—á–∞–Ω–∏–µ –¥–ª—è –º–∞–ª–µ–Ω—å–∫–æ–≥–æ –∫–æ—Ä–∞–±–ª—è
  
  const scale = 0.9; // –ú–µ–Ω—å—à–µ —Ä–∞–∑–º–µ—Ä
  const enginePulse = Math.abs(Math.sin(t * 0.015)) * 0.5 + 0.5;
  
  const mainColor = primaryColor;
  const engineColor = `rgba(50, 200, 255, ${enginePulse})`;
  const fillColor = primaryColor + 'EE'; // –ú–µ–Ω—å—à–µ –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏ (93%)
  
  if (fillShip) {
    ctx.fillStyle = fillColor;
    ctx.beginPath();
    // –û–±—Ç–µ–∫–∞–µ–º–∞—è —Ñ–æ—Ä–º–∞ —Ä–∞–∑–≤–µ–¥—á–∏–∫–∞
    ctx.moveTo(0, -25 * scale);
    ctx.bezierCurveTo(-12 * scale, -22 * scale, -20 * scale, -15 * scale, -22 * scale, -5 * scale);
    ctx.bezierCurveTo(-25 * scale, 8 * scale, -18 * scale, 18 * scale, -10 * scale, 22 * scale);
    ctx.lineTo(10 * scale, 22 * scale);
    ctx.bezierCurveTo(18 * scale, 18 * scale, 25 * scale, 8 * scale, 22 * scale, -5 * scale);
    ctx.bezierCurveTo(20 * scale, -15 * scale, 12 * scale, -22 * scale, 0, -25 * scale);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.lineWidth = lineWidth;
  ctx.strokeStyle = mainColor;
  ctx.beginPath();
  
  // –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ—Ä–ø—É—Å
  ctx.moveTo(0, -25 * scale);
  ctx.bezierCurveTo(-12 * scale, -22 * scale, -20 * scale, -15 * scale, -22 * scale, -5 * scale);
  ctx.bezierCurveTo(-25 * scale, 8 * scale, -18 * scale, 18 * scale, -10 * scale, 22 * scale);
  ctx.lineTo(10 * scale, 22 * scale);
  ctx.bezierCurveTo(18 * scale, 18 * scale, 25 * scale, 8 * scale, 22 * scale, -5 * scale);
  ctx.bezierCurveTo(20 * scale, -15 * scale, 12 * scale, -22 * scale, 0, -25 * scale);
  
  // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è
  ctx.moveTo(0, -25 * scale);
  ctx.lineTo(0, 22 * scale);
  
  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -22; i <= 22; i += 2) {
    const y = i * scale;
    const width = 20 - Math.abs(i) * 0.4;
    ctx.moveTo(-width * scale, y);
    ctx.lineTo(width * scale, y);
  }
  
  // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –ø–∞–Ω–µ–ª–∏
  ctx.moveTo(-15 * scale, -10 * scale);
  ctx.bezierCurveTo(-20 * scale, -12 * scale, -23 * scale, -14 * scale, -25 * scale, -15 * scale);
  ctx.bezierCurveTo(-24 * scale, -10 * scale, -23 * scale, -7 * scale, -22 * scale, -5 * scale);
  
  ctx.moveTo(15 * scale, -10 * scale);
  ctx.bezierCurveTo(20 * scale, -12 * scale, 23 * scale, -14 * scale, 25 * scale, -15 * scale);
  ctx.bezierCurveTo(24 * scale, -10 * scale, 23 * scale, -7 * scale, 22 * scale, -5 * scale);
  
  // –ê–Ω—Ç–µ–Ω–Ω—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  ctx.moveTo(-8 * scale, -20 * scale);
  ctx.lineTo(-12 * scale, -28 * scale);
  ctx.moveTo(8 * scale, -20 * scale);
  ctx.lineTo(12 * scale, -28 * scale);
  ctx.moveTo(0, -25 * scale);
  ctx.lineTo(0, -32 * scale);
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –∞–Ω—Ç–µ–Ω–Ω—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  ctx.moveTo(-5 * scale, -22 * scale);
  ctx.lineTo(-8 * scale, -30 * scale);
  ctx.moveTo(5 * scale, -22 * scale);
  ctx.lineTo(8 * scale, -30 * scale);
  
  // –ï—â–µ –±–æ–ª—å—à–µ –∞–Ω—Ç–µ–Ω–Ω
  for (let i = -3; i <= 3; i += 3) {
    if (i === 0) continue;
    const x = i * scale;
    ctx.moveTo(x, -23 * scale);
    ctx.lineTo(x, -26 * scale);
  }
  
  // –î–≤–∏–≥–∞—Ç–µ–ª–∏
  ctx.moveTo(-8 * scale, 22 * scale);
  ctx.bezierCurveTo(-10 * scale, 25 * scale, -11 * scale, 27 * scale, -12 * scale, 30 * scale);
  ctx.lineTo(-4 * scale, 30 * scale);
  ctx.bezierCurveTo(-5 * scale, 27 * scale, -6 * scale, 25 * scale, -8 * scale, 22 * scale);
  
  ctx.moveTo(8 * scale, 22 * scale);
  ctx.bezierCurveTo(10 * scale, 25 * scale, 11 * scale, 27 * scale, 12 * scale, 30 * scale);
  ctx.lineTo(4 * scale, 30 * scale);
  ctx.bezierCurveTo(5 * scale, 27 * scale, 6 * scale, 25 * scale, 8 * scale, 22 * scale);
  
  // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -18; i <= 18; i += 6) {
    const x = i * scale;
    ctx.moveTo(x - 2 * scale, -5 * scale);
    ctx.lineTo(x + 2 * scale, -5 * scale);
    ctx.moveTo(x - 2 * scale, -8 * scale);
    ctx.lineTo(x + 2 * scale, -8 * scale);
  }
  
  // –ö–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–∞–Ω–µ–ª–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -15; i <= 15; i += 5) {
    const x = i * scale;
    ctx.moveTo(x - 1.5 * scale, 5 * scale);
    ctx.lineTo(x + 1.5 * scale, 5 * scale);
    ctx.moveTo(x - 1.5 * scale, 8 * scale);
    ctx.lineTo(x + 1.5 * scale, 8 * scale);
  }
  
  // –°–∏—Å—Ç–µ–º—ã –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
  ctx.moveTo(-3 * scale, -18 * scale);
  ctx.lineTo(-6 * scale, -15 * scale);
  ctx.moveTo(3 * scale, -18 * scale);
  ctx.lineTo(6 * scale, -15 * scale);
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–µ–Ω—Å–æ—Ä—ã
  for (let i = -10; i <= 10; i += 10) {
    const x = i * scale;
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x - 1 * scale, 15 * scale);
    ctx.lineTo(x + 1 * scale, 15 * scale);
  }
  
  ctx.stroke();
  
  // –î–µ—Ç–∞–ª–∏ —Å –∞–∫—Ü–µ–Ω—Ç–Ω—ã–º —Ü–≤–µ—Ç–æ–º
  ctx.strokeStyle = accentColor;
  ctx.lineWidth = lineWidth * 0.6;
  
  ctx.beginPath();
  
  // –°–µ–Ω—Å–æ—Ä–Ω—ã–µ —Ä–µ—à–µ—Ç–∫–∏ (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -18; i <= 18; i += 2) {
    const x = i * scale;
    const curve = Math.sin(i * 0.3) * 3;
    const height = 20 - Math.abs(i) * 0.4 + curve;
    ctx.moveTo(x, -20 * scale);
    ctx.lineTo(x, height * scale);
  }
  
  // –ü–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -12; i <= 12; i += 3) {
    const x = i * scale;
    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ø–∞–Ω–µ–ª–∏
    ctx.moveTo(x, -12 * scale);
    ctx.lineTo(x, -8 * scale);
    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø–∞–Ω–µ–ª–∏
    ctx.moveTo(x - 1.5 * scale, -10 * scale);
    ctx.lineTo(x + 1.5 * scale, -10 * scale);
  }
  
  // –¢–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø–æ—Ä—Ç—ã (–æ—á–µ–Ω—å –ø–ª–æ—Ç–Ω–∞—è —Å–µ—Ç–∫–∞)
  for (let i = -16; i <= 16; i += 8) {
    const x = i * scale;
    ctx.moveTo(x - 1 * scale, 12 * scale);
    ctx.lineTo(x + 1 * scale, 12 * scale);
    ctx.moveTo(x - 1 * scale, 15 * scale);
    ctx.lineTo(x + 1 * scale, 15 * scale);
  }
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏
  for (let i = -14; i <= 14; i += 14) {
    const x = i * scale;
    for (let j = -5; j <= 5; j += 5) {
      const y = j * scale;
      ctx.moveTo(x - 0.5 * scale, y);
      ctx.lineTo(x + 0.5 * scale, y);
    }
  }
  
  ctx.stroke();
  
  // –î–≤–∏–≥–∞—Ç–µ–ª–∏
  ctx.strokeStyle = engineColor;
  ctx.lineWidth = lineWidth * 1.3;
  
  ctx.beginPath();
  
  for (let i = 1; i <= 6; i++) {
    const length = 5 + i * 1.2;
    const spread = i * 0.3;
    ctx.moveTo(-8 * scale - spread, 30 * scale);
    ctx.lineTo(-8 * scale - spread, 30 * scale + length);
    ctx.moveTo(-8 * scale + spread, 30 * scale);
    ctx.lineTo(-8 * scale + spread, 30 * scale + length);
    
    ctx.moveTo(8 * scale - spread, 30 * scale);
    ctx.lineTo(8 * scale - spread, 30 * scale + length);
    ctx.moveTo(8 * scale + spread, 30 * scale);
    ctx.lineTo(8 * scale + spread, 30 * scale + length);
  }
  
  ctx.stroke();
  ctx.restore();
}

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
function checkCollision() {
  if (!UI.gameMode || Game.crashed) return false;
  
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –±–ª–∏–∂–∞–π—à–∏–º —Ä—è–¥–æ–º –ª–∞–Ω–¥—à–∞—Ñ—Ç–∞
  const nearestRow = grid[5]; // –ë–ª–∏–∂–∞–π—à–∏–π –≤–∏–¥–∏–º—ã–π —Ä—è–¥
  const shipWorldX = Game.shipX * 0.1; // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –ø–æ–∑–∏—Ü–∏—é –∫–æ—Ä–∞–±–ª—è
  
  // –ù–∞—Ö–æ–¥–∏–º —Å–µ–≥–º–µ–Ω—Ç, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –ø–æ–∑–∏—Ü–∏–∏ –∫–æ—Ä–∞–±–ª—è
  const segmentIndex = Math.floor((shipWorldX / 1200 + 0.5) * segments);
  
  if (segmentIndex >= 0 && segmentIndex < nearestRow.length) {
    const terrainHeight = nearestRow[segmentIndex].y;
    // –ï—Å–ª–∏ –≤—ã—Å–æ—Ç–∞ terrainHeight –±–æ–ª—å—à–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞ - —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ
    if (terrainHeight > 30) {
      Game.crashed = true;
      return true;
    }
  }
  
  return false;
}

// main draw loop
let lastT = 0;
function draw(t){
  if(!lastT) lastT = t;
  const dt = Math.min(50, t - lastT) / 1000; lastT = t;
  
  if(!paused) {
    timeOffset += dt * UI.speed * 1.0;
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    if (UI.gameMode && !Game.crashed) {
      Game.distance += UI.speed * dt * 100;
      
      // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª–µ–º
      const moveSpeed = 200 * dt;
      if (Game.keys.left) Game.shipX -= moveSpeed;
      if (Game.keys.right) Game.shipX += moveSpeed;
      
      // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
      Game.shipX = Math.max(-400, Math.min(400, Game.shipX));
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
      checkCollision();
      
      // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI –∏–≥—Ä—ã
      $('gameSpeed').textContent = Math.round(UI.speed * 100);
      $('gameDistance').textContent = Math.round(Game.distance);
      $('gameStatus').textContent = Game.crashed ? 'üí• –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–ï!' : '‚úÖ –í –ø–æ–ª—ë—Ç–µ';
      $('gameStatus').style.color = Game.crashed ? '#ff5555' : '#55ff55';
    }
  }

  // clear
  ctx.clearRect(0,0,innerWidth,innerHeight);
  // background gradient
  const g = ctx.createLinearGradient(0,0,0,innerHeight);
  g.addColorStop(0,'#020418'); g.addColorStop(1,'#000006');
  ctx.fillStyle = g; ctx.fillRect(0,0,innerWidth,innerHeight);

  // camera
  const camera = {
    x: 0,
    y: 60, // —É–≤–µ–ª–∏—á–∏–ª–∏ –≤—ã—Å–æ—Ç—É –∫–∞–º–µ—Ä—ã –¥–ª—è –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏—Ö –ø–∏–∫–æ–≤
    z: -50,
    pitch: UI.pitch * Math.PI/180,
    fov: UI.fov,
    cx: innerWidth/2,
    cy: innerHeight * 0.45
  };

  // generate terrain heights procedurally for each grid point
  const widthWorld = 1200;
  for(let d=0; d<depthSteps; d++){
    const z = d / (depthSteps-1) * 1200;
    for(let s=0; s<=segments; s++){
      const x = (s / segments - 0.5) * widthWorld;
      const nx = x * (UI.freq * 0.002);
      const nz = (z * 0.002) + timeOffset * UI.speed * 0.1;
      // fbm noise —Å –±–æ–ª–µ–µ –æ—Å—Ç—Ä—ã–º–∏ –ø–∏–∫–∞–º–∏
      const h = fbm(nx, nz, 6, 2.2, 0.45); // –±–æ–ª—å—à–µ –æ–∫—Ç–∞–≤, –¥—Ä—É–≥–æ–π lacunarity/gain
      const y = (h - 0.3) * UI.amplitude * 2.5; // —É–≤–µ–ª–∏—á–µ–Ω –º–Ω–æ–∂–∏—Ç–µ–ª—å –¥–ª—è –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏—Ö –ø–∏–∫–æ–≤
      grid[d][s].x = x; grid[d][s].y = y; grid[d][s].z = z;
    }
  }

  // drawing lines: far to near
  ctx.lineWidth = UI.lineWidth;
  ctx.globalAlpha = 1.0;

  // contours (rows)
  for(let d=depthSteps-1; d>=0; d--){
    const depthRatio = d / depthSteps;
    ctx.strokeStyle = getGradientColor(UI.color, depthRatio);
    ctx.beginPath();
    let firstValid = false;
    for(let s=0; s<=segments; s++){
      const p = grid[d][s];
      const proj = projectPoint(p.x, p.y, p.z, camera);
      if(!proj) continue;
      if(!firstValid){ ctx.moveTo(proj.sx, proj.sy); firstValid = true; }
      else ctx.lineTo(proj.sx, proj.sy);
    }
    ctx.stroke();
  }

  // optional vertical grid lines (columns)
  if(UI.showGrid){
    for(let s=0; s<=segments; s+=Math.max(1,Math.floor(segments/80))){
      const depthRatio = s / segments;
      ctx.strokeStyle = getGradientColor(UI.color, depthRatio);
      ctx.beginPath();
      let first=false;
      for(let d=0; d<depthSteps; d++){
        const p = grid[d][s];
        const proj = projectPoint(p.x, p.y, p.z, camera);
        if(!proj) continue;
        if(!first){ ctx.moveTo(proj.sx, proj.sy); first=true; }
        else ctx.lineTo(proj.sx, proj.sy);
      }
      ctx.stroke();
    }
  }

  // draw ship based on selected type
  const shipBaseX = innerWidth/2;
  const shipBaseY = innerHeight * 0.76;
  const wobble = UI.shipWobble ? Math.sin(t*0.0025 * UI.speed) * 8 : 0;
  const bob = UI.shipWobble ? Math.sin(t*0.004 * UI.speed) * 6 : 0;
  
  // –í—ã–±–æ—Ä –∫–æ—Ä–∞–±–ª—è –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞
  switch(UI.shipType) {
    case '1':
      drawShipFighter(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
    case '2':
      drawShipCruiser(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
    case '3':
      drawShipScout(ctx, t, shipBaseX, shipBaseY, wobble, bob, UI.lineWidth + 0.4, UI.shipColor, UI.shipAccentColor, UI.shipFill);
      break;
  }

  // HUD horizon line subtle
  ctx.globalAlpha = 0.06;
  ctx.beginPath(); ctx.moveTo(0, camera.cy); ctx.lineTo(innerWidth, camera.cy); ctx.stroke(); ctx.globalAlpha = 1.0;

  requestAnimationFrame(draw);
}
requestAnimationFrame(draw);

// initial sync UI values
function syncUI(){
  $('speed').value = UI.speed;
  $('amplitude').value = UI.amplitude;
  $('freq').value = UI.freq;
  $('pitch').value = UI.pitch;
  $('fov').value = UI.fov;
  $('segments').value = UI.segments;
  $('depth').value = UI.depth;
  $('lineWidth').value = UI.lineWidth;
  $('color').value = UI.color;
  $('shipType').value = UI.shipType;
  $('shipColor').value = UI.shipColor;
  $('shipAccentColor').value = UI.shipAccentColor;
  $('showGrid').checked = UI.showGrid;
  $('shipWobble').checked = UI.shipWobble;
  $('shipFill').checked = UI.shipFill;
  $('gradientColor').checked = UI.gradientColor;
  $('gameMode').checked = UI.gameMode;
}
syncUI();

// keep canvas resized properly
setInterval(()=>{ resize(); }, 500);

</script>
</body>
</html>
