<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è —Ä—è–±—å</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            font-family: Arial, sans-serif;
            color: white;
        }
        
        canvas {
            display: block;
        }
        
        .info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
            transition: opacity 0.3s;
        }
        
        button {
            background: #4e54c8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
        }
        
        button:hover {
            background: #6a70e0;
        }
        
        .status {
            margin-top: 10px;
            font-size: 14px;
        }
        
        #camera-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 2px solid white;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
            display: none;
            transform: scaleX(-1); /* –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ */
        }
        
        #camera-label {
            position: absolute;
            bottom: 175px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            transition: opacity 0.3s;
        }
        
        .motion-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: red;
            display: none;
            z-index: 5;
            pointer-events: none;
            transition: transform 0.1s, opacity 0.3s;
            transform: scaleX(-1); /* –ó–µ—Ä–∫–∞–ª—å–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è */
        }
        
        .debug {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
            transition: opacity 0.3s;
        }
        
        .ui-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 10px;
            z-index: 20;
        }
        
        .control-btn {
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: scale(1.1);
        }
        
        .settings-panel {
            position: absolute;
            bottom: 70px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            width: 200px;
            display: none;
            z-index: 20;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        
        .settings-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        .settings-panel button {
            width: 100%;
            margin: 5px 0;
            padding: 8px;
            font-size: 14px;
        }
        
        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="info">
        <h2>–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∞—è —Ä—è–±—å</h2>
        <p>–£–∑–æ—Ä—ã —Ñ–∏–∑–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–º–µ—â–∞—é—Ç—Å—è, —Ä–µ–∞–≥–∏—Ä—É—è –Ω–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ–π –∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É—è –¥—Ä—É–≥ —Å –¥—Ä—É–≥–æ–º.</p>
        <button id="start-camera">–†–∞–∑—Ä–µ—à–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</button>
        <div id="status" class="status">–ö–∞–º–µ—Ä–∞ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞</div>
    </div>
    
    <div id="camera-label">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–∞–º–µ—Ä—ã</div>
    <video id="camera-preview" autoplay muted playsinline></video>
    <div id="motion-indicator" class="motion-indicator"></div>
    
    <div class="debug" id="debug-info"></div>
    
    <div class="ui-controls">
        <div class="control-btn" id="toggle-ui" title="–°–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å">üëÅ</div>
        <div class="control-btn" id="toggle-settings" title="–ù–∞—Å—Ç—Ä–æ–π–∫–∏">‚öô</div>
    </div>
    
    <div class="settings-panel" id="settings-panel">
        <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
        <button id="add-patterns">–î–æ–±–∞–≤–∏—Ç—å —É–∑–æ—Ä—ã</button>
        <button id="regenerate">–ü–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
        <button id="change-colors">–°–º–µ–Ω–∏—Ç—å —Ü–≤–µ—Ç–∞</button>
        <button id="resize-patterns">–ò–∑–º–µ–Ω–∏—Ç—å —Ä–∞–∑–º–µ—Ä</button>
    </div>
    
    <canvas id="ripple-canvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('ripple-canvas');
            const ctx = canvas.getContext('2d');
            const startButton = document.getElementById('start-camera');
            const statusElement = document.getElementById('status');
            const cameraPreview = document.getElementById('camera-preview');
            const motionIndicator = document.getElementById('motion-indicator');
            const debugInfo = document.getElementById('debug-info');
            const toggleUI = document.getElementById('toggle-ui');
            const toggleSettings = document.getElementById('toggle-settings');
            const settingsPanel = document.getElementById('settings-panel');
            const addPatternsBtn = document.getElementById('add-patterns');
            const regenerateBtn = document.getElementById('regenerate');
            const changeColorsBtn = document.getElementById('change-colors');
            const resizePatternsBtn = document.getElementById('resize-patterns');
            
            let videoStream = null;
            let video = null;
            let lastFrame = null;
            let motionData = {
                intensity: 0,
                x: 0.5,
                y: 0.5,
                active: false,
                force: { x: 0, y: 0 },
                points: []
            };
            
            let uiHidden = false;
            let patterns = [];
            const baseColors = ['#ff4d4d', '#4dff4d', '#4d4dff', '#ffff4d', '#ff4dff', '#4dffff'];
            let currentColors = [...baseColors];
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–∞–∑–º–µ—Ä–æ–≤ canvas
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º
            toggleUI.addEventListener('click', function() {
                uiHidden = !uiHidden;
                const elementsToToggle = [
                    document.querySelector('.info'), 
                    debugInfo, 
                    cameraPreview, 
                    document.getElementById('camera-label'),
                    motionIndicator // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–≤–∏–∂–µ–Ω–∏—è –≤ —Å–ø–∏—Å–æ–∫ —Å–∫—Ä—ã–≤–∞–µ–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
                ];
                
                elementsToToggle.forEach(el => {
                    if (el) {
                        el.classList.toggle('hidden', uiHidden);
                    }
                });
                
                toggleUI.textContent = uiHidden ? 'üëÅ‚Äçüó®' : 'üëÅ';
                toggleUI.title = uiHidden ? '–ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å' : '–°–∫—Ä—ã—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å';
            });
            
            toggleSettings.addEventListener('click', function() {
                settingsPanel.style.display = settingsPanel.style.display === 'block' ? 'none' : 'block';
            });
            
            // –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–∞–Ω–µ–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ –µ–µ
            document.addEventListener('click', function(e) {
                if (!settingsPanel.contains(e.target) && e.target !== toggleSettings) {
                    settingsPanel.style.display = 'none';
                }
            });
            
            // –ó–∞–ø—Ä–æ—Å –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ
            startButton.addEventListener('click', async function() {
                try {
                    videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 } 
                        } 
                    });
                    statusElement.textContent = '–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞. –î–≤–∏–≥–∞–π—Ç–µ—Å—å –ø–µ—Ä–µ–¥ –∫–∞–º–µ—Ä–æ–π!';
                    startButton.style.display = 'none';
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–∏–¥–µ–æ –≤ —ç–ª–µ–º–µ–Ω—Ç–µ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
                    cameraPreview.srcObject = videoStream;
                    cameraPreview.style.display = 'block';
                    
                    // –°–æ–∑–¥–∞–µ–º –≤–∏–¥–µ–æ —ç–ª–µ–º–µ–Ω—Ç –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–∞–¥—Ä–æ–≤
                    video = document.createElement('video');
                    video.srcObject = videoStream;
                    video.play();
                    video.width = 160;
                    video.height = 120;
                    
                    // –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–π canvas –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = video.width;
                    tempCanvas.height = video.height;
                    
                    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –¥–≤–∏–∂–µ–Ω–∏—è
                    processMotion(video, tempCanvas, tempCtx);
                } catch (err) {
                    statusElement.textContent = '–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ: ' + err.message;
                    console.error('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:', err);
                }
            });
            
            // –ê–Ω–∞–ª–∏–∑ –¥–≤–∏–∂–µ–Ω–∏—è –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏
            function processMotion(video, tempCanvas, tempCtx) {
                let lastMotionPoints = [];
                
                function analyzeFrame() {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);
                        const currentFrame = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                        
                        if (lastFrame) {
                            const motion = detectMotion(lastFrame, currentFrame);
                            
                            // –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â–∏–π –≤–µ–∫—Ç–æ—Ä —Å–∏–ª—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è —Ç–æ—á–µ–∫ –¥–≤–∏–∂–µ–Ω–∏—è
                            motionData.force = calculateForce(lastMotionPoints, motion.points);
                            
                            // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –æ –¥–≤–∏–∂–µ–Ω–∏–∏
                            motionData.intensity = motion.intensity;
                            motionData.x = motion.centerX;
                            motionData.y = motion.centerY;
                            motionData.active = motion.detected;
                            motionData.points = motion.points;
                            
                            lastMotionPoints = motion.points;
                            
                            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –¥–≤–∏–∂–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ UI –Ω–µ —Å–∫—Ä—ã—Ç
                            if (motion.detected && !uiHidden) {
                                motionIndicator.style.display = 'block';
                                // –ó–µ—Ä–∫–∞–ª–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É X –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                                motionIndicator.style.left = ((1 - motion.centerX) * canvas.width - 10) + 'px';
                                motionIndicator.style.top = (motion.centerY * canvas.height - 10) + 'px';
                                
                                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
                                const scale = 1 + motion.intensity * 2;
                                motionIndicator.style.transform = `scaleX(-1) scale(${scale})`;
                            } else {
                                motionIndicator.style.display = 'none';
                            }
                            
                            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                            debugInfo.innerHTML = `
                                –ò–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å: ${motion.intensity.toFixed(2)}<br>
                                –¶–µ–Ω—Ç—Ä: (${motion.centerX.toFixed(2)}, ${motion.centerY.toFixed(2)})<br>
                                –°–∏–ª–∞: (${motionData.force.x.toFixed(2)}, ${motionData.force.y.toFixed(2)})<br>
                                –¢–æ—á–µ–∫: ${motion.points.length}
                            `;
                        }
                        
                        lastFrame = currentFrame;
                    }
                    
                    requestAnimationFrame(analyzeFrame);
                }
                
                analyzeFrame();
            }
            
            // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è –∫–∞–¥—Ä–∞–º–∏
            function detectMotion(frame1, frame2) {
                let totalDiff = 0;
                let motionPoints = [];
                let centerX = 0;
                let centerY = 0;
                let motionPixels = 0;
                
                const width = frame1.width;
                const height = frame1.height;
                const data1 = frame1.data;
                const data2 = frame2.data;
                
                for (let y = 0; y < height; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const i = (y * width + x) * 4;
                        
                        const diff = Math.abs(data1[i] - data2[i]) + 
                                     Math.abs(data1[i+1] - data2[i+1]) + 
                                     Math.abs(data1[i+2] - data2[i+2]);
                        
                        if (diff > 30) {
                            totalDiff += diff;
                            motionPixels++;
                            
                            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ—á–∫—É –¥–≤–∏–∂–µ–Ω–∏—è
                            motionPoints.push({
                                x: x / width,
                                y: y / height,
                                intensity: diff / 765 // –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å (0-1)
                            });
                            
                            centerX += x;
                            centerY += y;
                        }
                    }
                }
                
                const intensity = Math.min(1, totalDiff / (width * height * 3 * 255));
                const detected = motionPixels > (width * height * 0.005);
                
                // –í—ã—á–∏—Å–ª—è–µ–º —Ü–µ–Ω—Ç—Ä –¥–≤–∏–∂–µ–Ω–∏—è
                let centerMotionX = 0.5;
                let centerMotionY = 0.5;
                if (motionPixels > 0) {
                    centerMotionX = (centerX / motionPixels) / width;
                    centerMotionY = (centerY / motionPixels) / height;
                }
                
                return {
                    detected,
                    intensity,
                    centerX: centerMotionX,
                    centerY: centerMotionY,
                    points: motionPoints
                };
            }
            
            // –í—ã—á–∏—Å–ª–µ–Ω–∏–µ —Å–∏–ª—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ–ª–æ–∂–µ–Ω–∏—è —Ç–æ—á–µ–∫ –¥–≤–∏–∂–µ–Ω–∏—è
            function calculateForce(lastPoints, currentPoints) {
                if (lastPoints.length === 0 || currentPoints.length === 0) {
                    return { x: 0, y: 0 };
                }
                
                // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–∏–µ —Ç–æ—á–∫–∏ –º–µ–∂–¥—É –∫–∞–¥—Ä–∞–º–∏ –∏ –≤—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
                let totalForceX = 0;
                let totalForceY = 0;
                let matchedPoints = 0;
                
                for (let i = 0; i < Math.min(lastPoints.length, 10); i++) {
                    const lastPoint = lastPoints[i];
                    let minDistance = Infinity;
                    let closestPoint = null;
                    
                    for (let j = 0; j < Math.min(currentPoints.length, 10); j++) {
                        const currentPoint = currentPoints[j];
                        const dx = currentPoint.x - lastPoint.x;
                        const dy = currentPoint.y - lastPoint.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < minDistance && distance < 0.2) {
                            minDistance = distance;
                            closestPoint = currentPoint;
                        }
                    }
                    
                    if (closestPoint) {
                        const force = (lastPoint.intensity + closestPoint.intensity) / 2;
                        totalForceX += (closestPoint.x - lastPoint.x) * force * 50;
                        totalForceY += (closestPoint.y - lastPoint.y) * force * 50;
                        matchedPoints++;
                    }
                }
                
                if (matchedPoints > 0) {
                    return {
                        x: totalForceX / matchedPoints,
                        y: totalForceY / matchedPoints
                    };
                }
                
                return { x: 0, y: 0 };
            }
            
            // –ö–ª–∞—Å—Å –¥–ª—è –≥–µ–æ–º–µ—Ç—Ä–∏—á–µ—Å–∫–∏—Ö —É–∑–æ—Ä–æ–≤ —Å –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω–æ–π —Ñ–∏–∑–∏–∫–æ–π
            class GeometricPattern {
                constructor(x, y, size, color, speed) {
                    // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                    this.originalX = x;
                    this.originalY = y;
                    
                    // –¢–µ–∫—É—â–∞—è –ø–æ–∑–∏—Ü–∏—è
                    this.x = x;
                    this.y = y;
                    
                    // –§–∏–∑–∏—á–µ—Å–∫–∏–µ —Å–≤–æ–π—Å—Ç–≤–∞
                    this.vx = 0;
                    this.vy = 0;
                    this.mass = size / 10;
                    
                    // –í–∏–∑—É–∞–ª—å–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞
                    this.size = size;
                    this.color = color;
                    this.speed = speed;
                    this.phase = Math.random() * Math.PI * 2;
                    this.baseAmplitude = 2 + Math.random() * 3;
                    this.rotation = Math.random() * Math.PI * 2;
                    this.rotationSpeed = (Math.random() - 0.5) * 0.01;
                    this.shape = Math.floor(Math.random() * 3);
                    
                    // –î–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –¥—Ä—É–≥–∏–º–∏ —É–∑–æ—Ä–∞–º–∏
                    this.neighbors = [];
                }
                
                update(patterns) {
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ñ–∞–∑—ã –¥–ª—è –±–∞–∑–æ–≤–æ–π –∞–Ω–∏–º–∞—Ü–∏–∏
                    this.phase += this.speed;
                    this.rotation += this.rotationSpeed;
                    
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —É—Å–∫–æ—Ä–µ–Ω–∏–µ
                    let ax = 0;
                    let ay = 0;
                    
                    // –°–∏–ª–∞ –æ—Ç –¥–≤–∏–∂–µ–Ω–∏—è –∫–∞–º–µ—Ä—ã
                    if (motionData.active) {
                        // –î–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω—è–µ–º —Å–∏–ª—É –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è
                        for (const point of motionData.points) {
                            // –ó–µ—Ä–∫–∞–ª–∏–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É X –¥–ª—è —Ç–æ—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                            const mirroredX = 1 - point.x;
                            const pointX = mirroredX * canvas.width;
                            const pointY = point.y * canvas.height;
                            
                            const dx = this.x - pointX;
                            const dy = this.y - pointY;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if (distance < 200) {
                                // –°–∏–ª–∞ –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏—è –æ—Ç —Ç–æ—á–∫–∏ –¥–≤–∏–∂–µ–Ω–∏—è
                                const force = point.intensity * (1 - distance / 200) * 2;
                                const directionX = dx / distance;
                                const directionY = dy / distance;
                                
                                ax += directionX * force / this.mass;
                                ay += directionY * force / this.mass;
                            }
                        }
                        
                        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–∏–ª–∞ –æ—Ç –æ–±—â–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                        // –ó–µ—Ä–∫–∞–ª–∏–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–∏–ª—ã –ø–æ X
                        ax += (-motionData.force.x) * motionData.intensity * 0.1 / this.mass;
                        ay += motionData.force.y * motionData.intensity * 0.1 / this.mass;
                    }
                    
                    // –°–∏–ª–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ –∏—Å—Ö–æ–¥–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ (–∫–∞–∫ –ø—Ä—É–∂–∏–Ω–∞)
                    const returnStrength = 0.05;
                    ax += (this.originalX - this.x) * returnStrength;
                    ay += (this.originalY - this.y) * returnStrength;
                    
                    // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ —É–∑–æ—Ä–∞–º–∏
                    for (const other of patterns) {
                        if (other === this) continue;
                        
                        const dx = this.x - other.x;
                        const dy = this.y - other.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const minDistance = this.size + other.size + 5;
                        
                        if (distance < minDistance && distance > 0) {
                            // –û—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ –ø—Ä–∏ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–∏
                            const force = (minDistance - distance) * 0.1;
                            const directionX = dx / distance;
                            const directionY = dy / distance;
                            
                            ax += directionX * force / this.mass;
                            ay += directionY * force / this.mass;
                        }
                    }
                    
                    // –°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ (–¥–µ–º–ø—Ñ–∏—Ä–æ–≤–∞–Ω–∏–µ)
                    const damping = 0.93;
                    this.vx = (this.vx + ax) * damping;
                    this.vy = (this.vy + ay) * damping;
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                    this.x += this.vx;
                    this.y += this.vy;
                    
                    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö canvas
                    const margin = this.size;
                    if (this.x < margin) {
                        this.x = margin;
                        this.vx *= -0.5;
                    }
                    if (this.x > canvas.width - margin) {
                        this.x = canvas.width - margin;
                        this.vx *= -0.5;
                    }
                    if (this.y < margin) {
                        this.y = margin;
                        this.vy *= -0.5;
                    }
                    if (this.y > canvas.height - margin) {
                        this.y = canvas.height - margin;
                        this.vy *= -0.5;
                    }
                }
                
                draw(ctx) {
                    ctx.save();
                    
                    // –í–æ–ª–Ω–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞
                    const wave = Math.sin(this.phase) * this.baseAmplitude;
                    const currentSize = this.size + wave;
                    
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    
                    // –ò–∑–º–µ–Ω—è–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–∫–æ—Ä–æ—Å—Ç–∏
                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    const alpha = 0.7 + Math.min(0.3, speed * 0.1);
                    ctx.globalAlpha = alpha;
                    
                    ctx.fillStyle = this.color;
                    
                    switch (this.shape) {
                        case 0: // –ö—Ä—É–≥
                            ctx.beginPath();
                            ctx.arc(0, 0, currentSize, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case 1: // –ö–≤–∞–¥—Ä–∞—Ç
                            ctx.fillRect(-currentSize, -currentSize, currentSize * 2, currentSize * 2);
                            break;
                        case 2: // –¢—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫
                            ctx.beginPath();
                            ctx.moveTo(0, -currentSize);
                            ctx.lineTo(currentSize, currentSize);
                            ctx.lineTo(-currentSize, currentSize);
                            ctx.closePath();
                            ctx.fill();
                            break;
                    }
                    
                    ctx.restore();
                }
            }
            
            // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —É–∑–æ—Ä–∞–º–∏
            function createPatterns(count) {
                const newPatterns = [];
                for (let i = 0; i < count; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = 10 + Math.random() * 40;
                    const color = currentColors[Math.floor(Math.random() * currentColors.length)];
                    const speed = 0.01 + Math.random() * 0.03;
                    
                    newPatterns.push(new GeometricPattern(x, y, size, color, speed));
                }
                return newPatterns;
            }
            
            function initPatterns() {
                patterns = createPatterns(80);
            }
            
            function addMorePatterns() {
                const newPatterns = createPatterns(20);
                patterns.push(...newPatterns);
            }
            
            function regeneratePatterns() {
                patterns.forEach(pattern => {
                    pattern.x = pattern.originalX = Math.random() * canvas.width;
                    pattern.y = pattern.originalY = Math.random() * canvas.height;
                    pattern.vx = 0;
                    pattern.vy = 0;
                });
            }
            
            function changeColors() {
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—É—é –ø–∞–ª–∏—Ç—Ä—É —Ü–≤–µ—Ç–æ–≤
                currentColors = [];
                for (let i = 0; i < 6; i++) {
                    const hue = Math.floor(Math.random() * 360);
                    currentColors.push(`hsl(${hue}, 70%, 65%)`);
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–æ–≤—ã–µ —Ü–≤–µ—Ç–∞ –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º —É–∑–æ—Ä–∞–º
                patterns.forEach(pattern => {
                    pattern.color = currentColors[Math.floor(Math.random() * currentColors.length)];
                });
            }
            
            function resizePatterns() {
                patterns.forEach(pattern => {
                    const newSize = 5 + Math.random() * 50;
                    pattern.size = newSize;
                    pattern.mass = newSize / 10;
                });
            }
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫ –Ω–∞—Å—Ç—Ä–æ–µ–∫
            addPatternsBtn.addEventListener('click', function() {
                addMorePatterns();
                settingsPanel.style.display = 'none';
            });
            
            regenerateBtn.addEventListener('click', function() {
                regeneratePatterns();
                settingsPanel.style.display = 'none';
            });
            
            changeColorsBtn.addEventListener('click', function() {
                changeColors();
                settingsPanel.style.display = 'none';
            });
            
            resizePatternsBtn.addEventListener('click', function() {
                resizePatterns();
                settingsPanel.style.display = 'none';
            });
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
            initPatterns();
            
            // –ê–Ω–∏–º–∞—Ü–∏—è
            function animate() {
                ctx.fillStyle = 'rgba(26, 26, 46, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏ –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —É–∑–æ—Ä–æ–≤
                patterns.forEach(pattern => {
                    pattern.update(patterns);
                    pattern.draw(ctx);
                });
                
                requestAnimationFrame(animate);
            }
            
            animate();
        });
    </script>
</body>
</html>
